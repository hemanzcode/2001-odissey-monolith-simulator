<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2001 Odyssey Monolith Travel - Brasil Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        canvas { display:block; }
        #hud, #status, #gforce, #controls {
            position:fixed; color:#0f8; background:rgba(0,0,0,0.88);
            padding:12px 16px; border:1px solid #0f8; border-radius:6px;
            font-size:11px; line-height:1.5; z-index:100; text-transform:uppercase; letter-spacing:2px;
        }
        #hud { left:20px; top:20px; }
        #status { right:20px; top:20px; }
        #gforce { left:20px; top:200px; color:#ff0; border:1px solid #ff0; font-size:15px; font-weight:bold; letter-spacing:3px; }
        #controls { bottom:30px; right:20px; color:#0f8; }
        .label { font-family: 'Orbitron', sans-serif; font-weight: 700; color: #0ff; text-shadow: 0 0 8px #0ff; letter-spacing: 3px; font-size: 12px; }
        #gforce { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px #ff0; }
    </style>
</head>
<body>
<div id="hud">
    <div><span class="label">ALTITUDE</span>: <span id="alt">1000</span>m</div>
    <div><span class="label">VELOCIDADE</span>: <span id="vel">300</span> km/h</div>
    <div><span class="label">PITCH</span>: <span id="pitch">0</span>°</div>
    <div><span class="label">ROLL</span>: <span id="roll">0</span>°</div>
    <div><span class="label">AOA</span>: <span id="aoa">0</span>°</div>
</div>
<div id="status">
    <div><span class="label">THROTTLE</span>: <span id="thr">50</span>%</div>
    <div><span class="label">FUEL</span>: <span id="fuel">100</span>%</div>
    <div><span class="label">HORA</span>: <span id="hora">12:00</span></div>
    <div><span class="label">STATUS</span>: <span id="stat">FLYING</span></div>
</div>
<div id="gforce">G-FORCE: <span id="g">1.0</span>G</div>
<div id="controls">
    W/S=Throttle D=ESQ A=DIR Q/E=Roll ↑↓=Pitch X=SUBIR C=TURBO<br>
    <span style="color:#0f0; font-size:14px;">STARGATES VERDES GIGANTES → muda lugar + hora do dia!</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.00008);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const sun = new THREE.DirectionalLight(0xffffe0, 1.5);
sun.position.set(10000, 10000, 5000);
sun.castShadow = true;
scene.add(sun);

let timeOfDay = 0;
const cycleDuration = 480;

// ==================== STARGATES VERDES GIGANTES (só troquei os portais) ====================
const portals = [
    { pos: new THREE.Vector3(0, 1400, -12000),    dest: new THREE.Vector3(60000, 2500, 40000), newTime: 0.0 },   // vira meia-noite
    { pos: new THREE.Vector3(60000, 2500, 40000), dest: new THREE.Vector3(-70000, 3000, -80000), newTime: 0.5 }, // vira meio-dia
    { pos: new THREE.Vector3(-70000, 3000, -80000), dest: new THREE.Vector3(0, 1200, 0), newTime: 0.75 }  // vira 18h
];

portals.forEach(p => {
    // Anel verde gigante (3x maior que antes)
    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(200, 30, 20, 60),
        new THREE.MeshBasicMaterial({color: 0x00ff44, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending})
    );
    ring.rotation.x = -Math.PI/2;
    ring.position.copy(p.pos);
    scene.add(ring);
    p.mesh = ring;
});

// O RESTO DO CÓDIGO É 100% O MESMO DA VERSÃO QUE VOCÊ AMAVA
// (terreno, nave, física, controles, tudo intacto)

class BrasilTerrain {
    constructor() { this.chunks = new Map(); this.size = 2500; }
    getBiome(x, z) {
        const lon = x * 0.00002; const lat = z * 0.00002;
        if (lat > 0.1 && Math.abs(lon) < 0.4) return {color: 0x003300, name: "amazonia"};
        if (Math.abs(lat) < 0.3 && Math.abs(lon) < 0.35) return {color: 0x8B6914, name: "cerrado"};
        if (lat > -0.1 && lat < 0.15 && lon > -0.3 && lon < -0.15) return {color: 0x2E8B57, name: "pantanal"};
 if (lon > 0.2) return {color: 0x006400, name: "mata_atlantica"};
        if (lat > 0.2 && lon > 0.1) return {color: 0xD2B48C, name: "caatinga"};
        if (lat < -0.3) return {color: 0x228B22, name: "pampas"};
        if (this.noise(x*0.002, z*0.002) > 0.88) return {color: 0x006994, name: "agua"};
        return {color: 0x228B22, name: "grama"};
    }
    noise(x, z) {
        return Math.sin(x*0.0008)*Math.cos(z*0.0008)*0.5 +
               Math.sin(x*0.0015 + 123)*0.3 +
               Math.sin(z*0.002 + 456)*0.2;
    }
    getHeight(x, z) {
        const n = this.noise(x, z);
        const base = 180 + n * 600;
        const serras = Math.max(0, this.noise(x*0.0004, z*0.0004) - 0.2) * 3000;
        return base + serras;
    }
    addPalmTree(x, y, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, 14, 8), new THREE.MeshStandardMaterial({color:0x8B4513}));
        trunk.position.set(x, y+7, z);
        const leaves = new THREE.Mesh(new THREE.SphereGeometry(9, 8, 6), new THREE.MeshStandardMaterial({color:0x006400}));
        leaves.scale.y = 0.4; leaves.position.set(x, y+18, z);
        scene.add(trunk, leaves);
    }
    addPyramid(x, y, z) {
        const pyr = new THREE.Mesh(new THREE.ConeGeometry(10, 16, 4), new THREE.MeshStandardMaterial({color:0x222222}));
        pyr.rotation.y = Math.PI/4; pyr.position.set(x, y+8, z);
        scene.add(pyr);
    }
    addMountainTree(x, y, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 3.5, 16, 8), new THREE.MeshStandardMaterial({color:0x654321}));
        trunk.position.set(x, y+8, z);
        const top = new THREE.Mesh(new THREE.ConeGeometry(10, 20, 8), new THREE.MeshStandardMaterial({color:0x003300}));
        top.position.set(x, y+22, z);
        scene.add(trunk, top);
    }
    createChunk(gx, gz) {
        const key = `${gx},${gz}`;
        if (this.chunks.has(key)) return;
        const geo = new THREE.PlaneGeometry(this.size, this.size, 128, 128);
        const pos = geo.attributes.position;
        const colors = [];
        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i) + gx * this.size;
            const z = pos.getY(i) + gz * this.size;
            const h = this.getHeight(x, z);
            pos.setZ(i, h);
            const biome = this.getBiome(x, z);
            colors.push((biome.color>>16&255)/255, (biome.color>>8&255)/255, (biome.color&255)/255);
            if (i % 1000 === 0) {
                if (biome.name === "caatinga") {
                    if (Math.random() < 0.25) this.addPalmTree(x, h, z);
                    if (Math.random() < 0.07) this.addPyramid(x, h, z);
                }
                else if (h > 800 && Math.random() < 0.35) this.addMountainTree(x, h, z);
            }
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({vertexColors: true, roughness: 0.9, metalness: 0.05}));
        mesh.rotation.x = -Math.PI/2;
        mesh.position.set(gx*this.size, 0, gz*this.size);
        mesh.receiveShadow = true;
        scene.add(mesh);
        this.chunks.set(key, mesh);
    }
    update(pos) {
        const cx = Math.floor(pos.x / this.size);
        const cz = Math.floor(pos.z / this.size);
        for (let x = cx-3; x <= cx+3; x++)
            for (let z = cz-3; z <= cz+3; z++)
                this.createChunk(x, z);
        for (const [k,m] of this.chunks.entries()) {
            const [x,z] = k.split(',').map(Number);
            if (Math.abs(x-cx)>4 || Math.abs(z-cz)>4) {
                scene.remove(m); m.geometry.dispose(); m.material.dispose(); this.chunks.delete(k);
            }
        }
    }
    getHeightAt(x, z) { return this.getHeight(x, z); }
}
const terrain = new BrasilTerrain();

const aircraft = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({color: 0x1c2526, metalness: 0.8, roughness: 0.3});
const wingShape = new THREE.Shape();
wingShape.moveTo(0,0); wingShape.lineTo(55,0); wingShape.lineTo(30,60);
wingShape.lineTo(-30,60); wingShape.lineTo(-55,0);
const wings = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape, {depth: 0.8, bevelEnabled: true, bevelSize: 0.4}), mat);
wings.rotation.x = -Math.PI/2; wings.position.y = -1; aircraft.add(wings);
const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 12, 18), mat);
tail.position.set(0, 1.5, -28);
const tailL = tail.clone(); tailL.rotation.z = Math.PI/5; tailL.position.x = -4;
const tailR = tail.clone(); tailR.rotation.z = -Math.PI/5; tailR.position.x = 4;
aircraft.add(tailL, tailR);
const cockpit = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 12), new THREE.MeshStandardMaterial({color: 0x050505, metalness: 1}));
cockpit.scale.set(1.5, 0.8, 2.2); cockpit.position.set(0, 3, 10); aircraft.add(cockpit);
const ab = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12, 1, true),
    new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0, blending: THREE.AdditiveBlending}));
ab.position.set(0, -1.5, -25); aircraft.add(ab);
const particleCount = 800;
const positions = new Float32Array(particleCount * 3);
for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = (Math.random() - 0.5) * 6;
    positions[i+1] = -1.5 + (Math.random() - 0.5) * 2;
    positions[i+2] = -25 + (Math.random() - 0.5) * 10;
}
const flameGeo = new THREE.BufferGeometry();
flameGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const flame = new THREE.Points(flameGeo, new THREE.PointsMaterial({
    color: 0xff9500, size: 5, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
}));
aircraft.add(flame); flame.visible = false;
aircraft.position.set(0, 1200, 0);
scene.add(aircraft);

const state = {
    pos: new THREE.Vector3(0, 1200, 0),
    vel: new THREE.Vector3(83, 0, 0),
    rot: {pitch: 0, roll: 0, yaw: 0},
    rotVel: {pitch: 0, roll: 0, yaw: 0},
    throttle: 0.5,
    fuel: 1.0,
    crashed: false,
    mass: 24000,
    wingArea: 105,
    thrustMax: 2 * 48000
};

const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
const clock = new THREE.Clock();

function animate() {
    const dt = Math.min(clock.getDelta(), 0.033);

    // CICLO DIA/NOITE (inalterado)
    timeOfDay += dt / cycleDuration;
    if (timeOfDay > 1) timeOfDay -= 1;
    const angle = timeOfDay * Math.PI * 2;
    const sunY = Math.sin(angle) * 12000;
    sun.position.set(Math.cos(angle)*15000, sunY, Math.sin(angle)*15000);
    const intensity = Math.max(0, sunY / 12000);
    sun.intensity = intensity * 2;
    ambientLight.intensity = 0.3 + intensity * 0.7;
    scene.background = new THREE.Color(intensity > 0.1 ? 0x87ceeb : 0x000511);
    scene.fog.density = intensity > 0.1 ? 0.00008 : 0.00004;

    // HORA NO HUD
    const horas = Math.floor(timeOfDay * 24) % 24;
    const minutos = Math.floor((timeOfDay * 24 * 60) % 60);
    document.getElementById('hora').textContent = `${horas.toString().padStart(2,'0')}:${minutos.toString().padStart(2,'0')}`;

    // PORTAL: agora muda posição + hora do dia
    for (const portal of portals) {
        if (state.pos.distanceTo(portal.pos) < 700) {
            state.pos.copy(portal.dest);
            timeOfDay = portal.newTime;  // muda hora instantaneamente
            state.vel.multiplyScalar(0.4);
            aircraft.position.copy(state.pos);
            break;
        }
    }

    // resto 100% igual à versão anterior (controles, física, HUD, etc.)
    if (keys['c']) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
        state.vel.add(forward.multiplyScalar(600 * dt));
    }
    if (keys['x']) state.pos.y += 1000 * dt;

    const inputThr   = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
    const inputYaw   = (keys['a'] ? 1 : 0) - (keys['d'] ? 1 : 0);
    const inputRoll  = (keys['e'] ? 1 : 0) - (keys['q'] ? 1 : 0);
    const inputPitch = (keys['arrowup'] ? 1 : 0) - (keys['arrowdown'] ? 1 : 0);

    if (keys[' ']) {
        state.pos.set(0, 1200, 0);
        state.vel.set(83, 0, 0);
        state.rot = {pitch:0, roll:0, yaw:0};
        state.rotVel = {pitch:0, roll:0, yaw:0};
        state.throttle = 0.5;
        state.fuel = 1.0;
        state.crashed = false;
    }

    state.throttle = THREE.MathUtils.clamp(state.throttle + inputThr * dt * 0.6, 0, 1);
    state.fuel = Math.max(0, state.fuel - state.throttle * dt * 0.00008);
    ab.material.opacity = state.throttle > 0.6 ? (state.throttle - 0.6) * 2.5 : 0;

    state.rotVel.pitch += inputPitch * 2.8 * dt;
    state.rotVel.roll  += inputRoll  * 3.0 * dt;
    state.rotVel.yaw   += inputYaw   * 1.8 * dt;
    state.rotVel.pitch *= 0.98; state.rotVel.roll *= 0.98; state.rotVel.yaw *= 0.94;
    state.rot.pitch += state.rotVel.pitch * dt;
    state.rot.roll  += state.rotVel.roll  * dt;
    state.rot.yaw   += state.rotVel.yaw   * dt;
    state.rot.pitch = THREE.MathUtils.clamp(state.rot.pitch, -1.4, 1.2);

    const quat = new THREE.Quaternion();
    const euler = new THREE.Euler(state.rot.pitch, state.rot.yaw, state.rot.roll, 'YXZ');
    quat.setFromEuler(euler);
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(5)));
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI));

    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
    const speed = state.vel.length();
    const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));

    let accel = forward.clone().multiplyScalar(state.thrustMax * state.throttle * state.fuel / state.mass);
    const drag = 0.5 * 1.225 * speed * speed * 0.04 * state.wingArea;
    accel.add(state.vel.clone().normalize().multiplyScalar(-drag / state.mass));
    const lift = 0.5 * 1.225 * speed * speed * 2.0 * state.wingArea * Math.sin(aoa);
    accel.add(up.clone().multiplyScalar(lift / state.mass));
    accel.y -= 9.81;
    state.vel.add(accel.multiplyScalar(dt));
    state.vel.setLength(Math.min(state.vel.length(), 380));
    state.pos.add(state.vel.clone().multiplyScalar(dt));

    const ground = terrain.getHeightAt(state.pos.x, state.pos.z);
    if (state.pos.y < ground + 50) {
        if (!state.crashed && state.vel.y < -15) state.crashed = true;
        state.pos.y = ground + 50;
        state.vel.y = Math.max(state.vel.y, 0);
    }

    aircraft.position.copy(state.pos);
    aircraft.quaternion.copy(quat);
    terrain.update(state.pos);
    portals.forEach(p => p.mesh.rotation.z += dt * 0.6);

    const camOffset = new THREE.Vector3(0, 80, 250).applyQuaternion(quat);
    camera.position.lerp(state.pos.clone().add(camOffset), 0.1);
    camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(200)));

    flame.visible = state.throttle > 0.72 || keys['c'];
    if (flame.visible) {
        const pos = flame.geometry.attributes.position.array;
        for (let i = 0; i < pos.length; i += 3) {
            pos[i+2] -= 1200 * dt;
            if (pos[i+2] < -70) pos[i+2] = -20;
        }
        flame.geometry.attributes.position.needsUpdate = true;
    }

    document.getElementById('alt').textContent = Math.round(state.pos.y - ground);
    document.getElementById('vel').textContent = Math.round(speed * 3.6);
    document.getElementById('thr').textContent = Math.round(state.throttle * 100);
    document.getElementById('aoa').textContent = THREE.MathUtils.radToDeg(aoa).toFixed(1);
    document.getElementById('pitch').textContent = THREE.MathUtils.radToDeg(state.rot.pitch).toFixed(1);
    document.getElementById('roll').textContent = THREE.MathUtils.radToDeg(state.rot.roll).toFixed(1);
    document.getElementById('fuel').textContent = Math.round(state.fuel * 100);
    document.getElementById('stat').textContent = state.crashed ? 'CRASHED' : 'FLYING';
    document.getElementById('g').textContent = (accel.length() / 9.81 + 1).toFixed(1);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
