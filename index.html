<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2001 Odyssey Monolith Travel - Brasil Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; background:#000; font-family:'Courier New',monospace; }
        canvas { display:block; }
        #hud, #status, #gforce, #controls {
            position:fixed; color:#0f8; background:rgba(0,0,0,0.88);
            padding:12px 16px; border:1px solid #0f8; border-radius:6px;
            font-size:11px; line-height:1.5; z-index:100; text-transform:uppercase; letter-spacing:2px;
        }
        #hud { left:20px; top:20px; }
        #status { right:20px; top:20px; }
        #gforce { left:20px; top:200px; color:#ff0; border:1px solid #ff0; font-size:15px; font-weight:bold; letter-spacing:3px; }
        #controls { bottom:30px; right:20px; }
        .label { font-family: 'Orbitron', sans-serif; font-weight: 700; color: #0ff; text-shadow: 0 0 8px #0ff; letter-spacing: 3px; font-size: 12px; }
        #gforce { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px #ff0; }
    </style>
</head>
<body>
<div id="hud">
    <div><span class="label">ALTITUDE</span>: <span id="alt">1000</span>m</div>
    <div><span class="label">VELOCIDADE</span>: <span id="vel">300</span> km/h</div>
    <div><span class="label">PITCH</span>: <span id="pitch">0</span>°</div>
    <div><span class="label">ROLL</span>: <span id="roll">0</span>°</div>
    <div><span class="label">AOA</span>: <span id="aoa">0</span>°</div>
</div>
<div id="status">
    <div><span class="label">THROTTLE</span>: <span id="thr">50</span>%</div>
    <div><span class="label">FUEL</span>: <span id="fuel">100</span>%</div>
    <div><span class="label">DISTÂNCIA</span>: <span id="dist">0</span>km</div>
    <div><span class="label">STATUS</span>: <span id="stat">FLYING</span></div>
</div>
<div id="gforce">G-FORCE: <span id="g">1.0</span>G</div>
<div id="controls">
    W/S=Throttle  A/D=Yaw  Q/E=Roll  ↑↓=Pitch  X=ASCEND  C=ACELERAR FORTE  SPACE=Reset
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.FogExp2(0x87ceeb, 0.00012);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 150000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

let timeOfDay = 0;
const cycleDuration = 600;

scene.add(new THREE.AmbientLight(0xffffff, 0.7));
const sun = new THREE.DirectionalLight(0xffffff, 1.2);
sun.position.set(5000, 8000, 3000);
sun.castShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
scene.add(sun);

// ==================== TERRENO 100% BRASILEIRO ====================
class BrasilTerrain {
    constructor() { this.chunks = new Map(); this.size = 2500; }

    // Simulação de biomas brasileiros usando coordenadas "geográficas"
    getBiome(x, z) {
        const lon = x * 0.00002;   // simula longitude
        const lat = z * 0.00002;   // simula latitude

        // Amazônia (norte)
        if (lat > 0.1 && Math.abs(lon) < 0.4) return {color: 0x003300, name: "amazonia"};
        // Cerrado (centro)
        if (Math.abs(lat) < 0.3 && Math.abs(lon) < 0.35) return {color: 0x8B6914, name: "cerrado"};
        // Pantanal
        if (lat > -0.1 && lat < 0.15 && lon > -0.3 && lon < -0.15) return {color: 0x2E8B57, name: "pantanal"};
        // Mata Atlântica (leste/sudeste)
        if (lon > 0.2) return {color: 0x006400, name: "mata_atlantica"};
        // Caatinga (nordeste)
        if (lat > 0.2 && lon > 0.1) return {color: 0xD2B48C, name: "caatinga"};
        // Pampas (sul)
        if (lat < -0.3) return {color: 0x228B22, name: "pampas"};
        // Água (rios, costa)
        if (this.noise(x*0.002, z*0.002) > 0.88) return {color: 0x006994, name: "agua"};
        return {color: 0x228B22, name: "grama"};
    }

    noise(x, z) {
        return Math.sin(x*0.0008)*Math.cos(z*0.0008)*0.5 +
               Math.sin(x*0.0015 + 123)*0.3 +
               Math.sin(z*0.002 + 456)*0.2;
    }

    getHeight(x, z) {
        const n = this.noise(x, z);
        const base = 180 + n * 600;
        const serras = Math.max(0, this.noise(x*0.0004, z*0.0004) - 0.2) * 3000;
        return base + serras;
    }

    createChunk(gx, gz) {
        const key = `${gx},${gz}`;
        if (this.chunks.has(key)) return;

        const geo = new THREE.PlaneGeometry(this.size, this.size, 128, 128);
        const pos = geo.attributes.position;
        const colors = [];

        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i) + gx * this.size;
            const z = pos.getY(i) + gz * this.size;
            const h = this.getHeight(x, z);
            pos.setZ(i, h);

            const biome = this.getBiome(x, z);
            colors.push(
                (biome.color >> 16 & 255)/255,
                (biome.color >> 8 & 255)/255,
                (biome.color & 255)/255
            );
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({
            vertexColors: true, roughness: 0.9, metalness: 0.05
        }));
        mesh.rotation.x = -Math.PI/2;
        mesh.position.set(gx*this.size, 0, gz*this.size);
        mesh.receiveShadow = true;
        scene.add(mesh);
        this.chunks.set(key, mesh);
    }

    update(pos) {
        const cx = Math.floor(pos.x / this.size);
        const cz = Math.floor(pos.z / this.size);
        for (let x = cx-3; x <= cx+3; x++)
            for (let z = cz-3; z <= cz+3; z++)
                this.createChunk(x, z);
        for (const [k,m] of this.chunks.entries()) {
            const [x,z] = k.split(',').map(Number);
            if (Math.abs(x-cx)>4 || Math.abs(z-cz)>4) {
                scene.remove(m); m.geometry.dispose(); m.material.dispose(); this.chunks.delete(k);
            }
        }
    }

    getHeightAt(x, z) { return this.getHeight(x, z); }
}
const terrain = new BrasilTerrain();

// ==================== RESTO DO CÓDIGO (NAVE, FÍSICA, ETC) ====================
// (mantive exatamente igual ao que já funcionava)

const aircraft = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({color: 0x1c2526, metalness: 0.8, roughness: 0.3});
const wingShape = new THREE.Shape();
wingShape.moveTo(0,0); wingShape.lineTo(55,0); wingShape.lineTo(30,60);
wingShape.lineTo(-30,60); wingShape.lineTo(-55,0);
const wings = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape, {depth: 0.8, bevelEnabled: true, bevelSize: 0.4}), mat);
wings.rotation.x = -Math.PI/2; wings.position.y = -1; aircraft.add(wings);

const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 12, 18), mat);
tail.position.set(0, 1.5, -28);
const tailL = tail.clone(); tailL.rotation.z = Math.PI/5; tailL.position.x = -4;
const tailR = tail.clone(); tailR.rotation.z = -Math.PI/5; tailR.position.x = 4;
aircraft.add(tailL, tailR);

const cockpit = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 12), new THREE.MeshStandardMaterial({color: 0x050505, metalness: 1}));
cockpit.scale.set(1.5, 0.8, 2.2); cockpit.position.set(0, 3, 10); aircraft.add(cockpit);

const ab = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12, 1, true),
    new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0, blending: THREE.AdditiveBlending}));
ab.position.set(0, -1.5, -25); aircraft.add(ab);

const particleCount = 800;
const positions = new Float32Array(particleCount * 3);
for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = (Math.random() - 0.5) * 6;
    positions[i+1] = -1.5 + (Math.random() - 0.5) * 2;
    positions[i+2] = -25 + (Math.random() - 0.5) * 10;
}
const flameGeo = new THREE.BufferGeometry();
flameGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const flame = new THREE.Points(flameGeo, new THREE.PointsMaterial({
    color: 0xff9500, size: 5, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
}));
aircraft.add(flame); flame.visible = false;

aircraft.position.set(0, 1200, 0);
scene.add(aircraft);

const state = {
    pos: new THREE.Vector3(0, 1200, 0),
    vel: new THREE.Vector3(83, 0, 0),
    rot: {pitch: 0, roll: 0, yaw: 0},
    rotVel: {pitch: 0, roll: 0, yaw: 0},
    throttle: 0.5,
    fuel: 1.0,
    crashed: false,
    mass: 24000,
    wingArea: 105,
    thrustMax: 2 * 48000
};

const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

const clock = new THREE.Clock();
function animate() {
    const dt = Math.min(clock.getDelta(), 0.033);

    timeOfDay += dt / cycleDuration; if (timeOfDay > 1) timeOfDay -= 1;
    const lightIntensity = Math.abs(Math.sin(timeOfDay * Math.PI));
    sun.intensity = 0.4 + lightIntensity * 1.0;
    scene.children[0].intensity = 0.3 + lightIntensity * 0.6;

    // === NOVIDADE: TECLA C = ACELERAR FORTE ===
    if (keys['c']) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
        state.vel.add(forward.multiplyScalar(600 * dt)); // aceleração brutal pra frente
    }

    // X continua subindo
    if (keys['x']) state.pos.y += 1000 * dt;

    const inputThr = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
    const inputYaw = (keys['d'] ? 1 : 0) - (keys['a'] ? 1 : 0);
    const inputRoll = (keys['e'] ? 1 : 0) - (keys['q'] ? 1 : 0);
    const inputPitch = (keys['arrowup'] ? 1 : 0) - (keys['arrowdown'] ? 1 : 0);

    if (keys[' ']) {
        state.pos.set(0, 1200, 0);
        state.vel.set(83, 0, 0);
        state.rot = {pitch:0, roll:0, yaw:0};
        state.rotVel = {pitch:0, roll:0, yaw:0};
        state.throttle = 0.5;
        state.fuel = 1.0;
        state.crashed = false;
    }

    // resto da física 100% igual ao original
    state.throttle = THREE.MathUtils.clamp(state.throttle + inputThr * dt * 0.6, 0, 1);
    state.fuel = Math.max(0, state.fuel - state.throttle * dt * 0.00008);
    ab.material.opacity = state.throttle > 0.6 ? (state.throttle - 0.6) * 2.5 : 0;

    state.rotVel.pitch += inputPitch * 2.8 * dt;
    state.rotVel.roll += inputRoll * 3.0 * dt;
    state.rotVel.yaw += inputYaw * 1.8 * dt;
    state.rotVel.pitch *= 0.98; state.rotVel.roll *= 0.98; state.rotVel.yaw *= 0.94;
    state.rot.pitch += state.rotVel.pitch * dt;
    state.rot.roll += state.rotVel.roll * dt;
    state.rot.yaw += state.rotVel.yaw * dt;
    state.rot.pitch = THREE.MathUtils.clamp(state.rot.pitch, -1.4, 1.2);

    const quat = new THREE.Quaternion();
    const euler = new THREE.Euler(state.rot.pitch, state.rot.yaw, state.rot.roll, 'YXZ');
    quat.setFromEuler(euler);
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(5)));
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI));

    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
    const speed = state.vel.length();
    const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));
    const aoaDeg = THREE.MathUtils.radToDeg(aoa);

    let accel = forward.clone().multiplyScalar(state.thrustMax * state.throttle * state.fuel / state.mass);
    const drag = 0.5 * 1.225 * speed * speed * 0.04 * state.wingArea;
    accel.add(state.vel.clone().normalize().multiplyScalar(-drag / state.mass));
    const lift = 0.5 * 1.225 * speed * speed * 2.0 * state.wingArea * Math.sin(aoa);
    accel.add(up.clone().multiplyScalar(lift / state.mass));
    accel.y -= 9.81;

    state.vel.add(accel.multiplyScalar(dt));
    state.vel.setLength(Math.min(state.vel.length(), 350)); // agora vai mais rápido com C
    state.pos.add(state.vel.clone().multiplyScalar(dt));

    const ground = terrain.getHeightAt(state.pos.x, state.pos.z);
    if (state.pos.y < ground + 50) {
        if (!state.crashed && state.vel.y < -15) state.crashed = true;
        state.pos.y = ground + 50;
        state.vel.y = Math.max(state.vel.y, 0);
    }

    aircraft.position.copy(state.pos);
    aircraft.quaternion.copy(quat);
    terrain.update(state.pos);

    const camOffset = new THREE.Vector3(0, 80, 250).applyQuaternion(quat);
    camera.position.lerp(state.pos.clone().add(camOffset), 0.1);
    camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(200)));

    flame.visible = state.throttle > 0.72 || keys['c'];
    if (flame.visible) {
        const pos = flame.geometry.attributes.position.array;
        for (let i = 0; i < pos.length; i += 3) {
            pos[i+2] -= 1200 * dt;
            if (pos[i+2] < -70) pos[i+2] = -20;
        }
        flame.geometry.attributes.position.needsUpdate = true;
    }

    document.getElementById('alt').textContent = Math.round(state.pos.y - ground);
    document.getElementById('vel').textContent = Math.round(speed * 3.6);
    document.getElementById('thr').textContent = Math.round(state.throttle * 100);
    document.getElementById('aoa').textContent = aoaDeg.toFixed(1);
    document.getElementById('pitch').textContent = THREE.MathUtils.radToDeg(state.rot.pitch).toFixed(1);
    document.getElementById('roll').textContent = THREE.MathUtils.radToDeg(state.rot.roll).toFixed(1);
    document.getElementById('fuel').textContent = Math.round(state.fuel * 100);
    document.getElementById('stat').textContent = state.crashed ? 'CRASHED' : 'FLYING';
    document.getElementById('dist').textContent = (state.pos.length() / 1000).toFixed(1);
    document.getElementById('g').textContent = (accel.length() / 9.81 + 1).toFixed(1);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
