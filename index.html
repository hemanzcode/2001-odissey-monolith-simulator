<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2001 Odyssey Monolith Travel - WARP DRIVE ATIVADO</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        canvas { display:block; }
        #hud, #status, #status, #gforce, #controls {
            position:fixed; color:#0f8; background:rgba(0,0,0,0.88);
            padding:12px 16px; border:1px solid #0f8; border-radius:6px;
            font-size:11px; line-height:1.5; z-index:100; text-transform:uppercase; letter-spacing:2px;
            font-family: 'Orbitron', sans-serif;
        }
        #hud { left:20px; top:20px; }
        #status { right:20px; top:20px; }
        #gforce { left:20px; top:200px; color:#ff0; border:1px solid #ff0; font-size:15px; font-weight:bold; }
        #controls { bottom:30px; right:20px; color:#0f8; }
        .label { color:#0ff; text-shadow:0 0 8px #0ff; font-weight:700; }
        #warp-countdown {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 60px; color: #00ff00; text-shadow: 0 0 20px #00ff00;
            font-family: 'Orbitron', sans-serif; z-index: 200; display: none;
        }
    </style>
</head>
<body>
<div id="hud">
    <div><span class="label">ALTITUDE</span>: <span id="alt">3000</span>m</div>
    <div><span class="label">VELOCIDADE</span>: <span id="vel">0</span> km/h</div>
    <div><span class="label">PITCH</span>: <span id="pitch">0</span>°</div>
    <div><span class="label">ROLL</span>: <span id="roll">0</span>°</div>
    <div><span class="label">AOA</span>: <span id="aoa">0</span>°</div>
</div>
<div id="status">
    <div><span class="label">THROTTLE</span>: <span id="thr">50</span>%</div>
    <div><span class="label">FUEL</span>: <span id="fuel">100</span>%</div>
    <div><span class="label">HORA</span>: <span id="hora">12:00</span></div>
    <div><span class="label">STATUS</span>: <span id="stat">FLYING</span></div>
</div>
<div id="gforce">G-FORCE: <span id="g">1.0</span>G</div>
<div id="controls">
    W/S=Throttle A/D=Yaw Q/E=Roll ↑↓=Pitch X=SUBIR C=TURBO Z=WARP 30x! SPACE=RESET<br>
    <span style="color:#0f0; font-size:14px;">WARP DRIVE 30x + OUTRAS NAVES NO ESPAÇO</span>
</div>
<div id="warp-countdown"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.000012);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 3000000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const sun = new THREE.DirectionalLight(0xffffe0, 2);
scene.add(sun);

const starGeo = new THREE.BufferGeometry();
const starPositions = new Float32Array(12000 * 3);
for (let i = 0; i < 12000; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 2000000 + Math.random() * 6000000;
    starPositions[i*3]   = r * Math.sin(phi) * Math.cos(theta);
    starPositions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
    starPositions[i*3+2] = r * Math.cos(phi);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 90, transparent:true, opacity:0.9}));
scene.add(stars);
stars.visible = false;

function createPlanet(radius, segments = 180, isBrasil = false, planetType = 'diverse') {
    const geo = new THREE.SphereGeometry(radius, segments, segments);
    const pos = geo.attributes.position;
    const colors = new Float32Array(pos.count * 3);
    const noise = (a, b, freq = 1, amp=1) => {
        return (Math.sin(a*freq*0.08 + 10)*Math.cos(b*freq*0.08 + 20))*amp;
    };
    const fbm = (lat, lon) => {
        let val = 0;
        val += noise(lat, lon, 1, 1);
        val += noise(lat, lon, 2.7, 0.5);
        val += noise(lat, lon, 6.3, 0.25);
        val += noise(lat, lon, 15, 0.12);
        return val;
    };
    const getBiome = (lat, lon) => {
        if (planetType === 'ice') {
            return {c:0xADD8E6, n:"ice"};
        }
        if (planetType === 'desert') {
            return {c:0xEDC9AF, n:"desert"};
        }
        if (planetType === 'blue') {
            if (Math.random() < 0.85) {
                return {c:0x00008B, n:"agua"};
            } else {
                return {c:0x228B22, n:"grama"};
            }
        }
        // diverse (default)
        if (isBrasil) lon -= 45;
        const n = fbm(lat*2, lon*2);
        if (lat > 8 && Math.abs(lon) < 55) return {c:0x003300, n:"amazonia"};
        if (Math.abs(lat + 18) < 40 && Math.abs(lon) < 45) return {c:0x8B6914, n:"cerrado"};
        if (lat > -25 && lat < -3 && lon > -30 && lon < -3) return {c:0x2E8B57, n:"pantanal"};
        if (lon > 8) return {c:0x006400, n:"mata_atlantica"};
        if (lat > -12 && lon > -18) return {c:0xD2B48C, n:"caatinga"};
        if (lat < -32) return {c:0x228B22, n:"pampas"};
        if (n > 0.9) return {c:0x006994, n:"agua"};
        if (n > 0.3) return {c:0x888888, n:"montanha"};
        return {c:0x228B22, n:"grama"};
    };
    for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
        const lat = Math.asin(z / radius) * 180 / Math.PI;
        const lon = Math.atan2(y, x) * 180 / Math.PI;
        let height = fbm(lat, lon) * 1200;
        height += Math.max(0, fbm(lat*0.4, lon*0.4) - 0.2) * 6000;
        height += Math.max(0, fbm(lat*8, lon*8) - 0.6) * 800;
        if (getBiome(lat, lon).n === "montanha") height += 4000;
        const dir = new THREE.Vector3(x,y,z).normalize().multiplyScalar(radius + height);
        pos.setXYZ(i, dir.x, dir.y, dir.z);
        const b = getBiome(lat, lon);
        colors[i*3]   = (b.c >> 16 & 255)/255;
        colors[i*3+1] = (b.c >> 8 & 255)/255;
        colors[i*3+2] = (b.c & 255)/255;
        if (b.n !== "agua" && b.n !== "ice" && b.n !== "desert" && radius > 60000 && i % Math.floor(400 - radius/800) === 0 && Math.random() < 0.9) {
            const worldPos = dir.clone().multiplyScalar(radius + height);
            const up = dir.clone().normalize();
            if ((b.n === "amazonia" || b.n === "mata_atlantica" || b.n === "grama") && (planetType === 'diverse' || planetType === 'blue')) {
                const tree = new THREE.Group();
                const trunkH = 120 + Math.random()*80;
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(12, 20, trunkH), new THREE.MeshStandardMaterial({color:0x8B4513}));
                trunk.position.copy(worldPos.clone().add(up.clone().multiplyScalar(trunkH/2)));
                trunk.lookAt(worldPos); tree.add(trunk);
                const leaves = new THREE.Mesh(new THREE.SphereGeometry(80), new THREE.MeshStandardMaterial({color:0x004400}));
                leaves.scale.y = 0.5;
                leaves.position.copy(worldPos.clone().add(up.clone().multiplyScalar(trunkH + 40)));
                leaves.lookAt(worldPos); tree.add(leaves);
                scene.add(tree);
            }
            if (Math.random() < 0.5) {
                const pyrH = 800 + Math.random()*800;
                const pyr = new THREE.Mesh(new THREE.ConeGeometry(pyrH*0.8, pyrH, 4), new THREE.MeshStandardMaterial({color:0x0a0a0a, emissive:0x111111}));
                pyr.position.copy(worldPos.clone().add(up.clone().multiplyScalar(pyrH/2)));
                pyr.lookAt(0,0,0);
                pyr.rotateX(Math.PI/2);
                pyr.rotation.y = Math.random() * Math.PI;
                scene.add(pyr);
            }
            if (Math.random() < 0.45) {
                const zig = new THREE.Group();
                for(let s=0; s<5; s++){
                    const size = 300 - s*50;
                    const level = new THREE.Mesh(new THREE.BoxGeometry(size, 60, size), new THREE.MeshStandardMaterial({color:0x3c2f2f}));
                    level.position.copy(worldPos.clone().add(up.clone().multiplyScalar(100 + s*70)));
                    level.lookAt(worldPos);
                    zig.add(level);
                }
                scene.add(zig);
            }
            if (Math.random() < 0.3) {
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(30, 60, 1200), new THREE.MeshStandardMaterial({color:0x88ccff, emissive:0x0088ff, emissiveIntensity:0.8, transparent:true, opacity:0.7}));
                tower.position.copy(worldPos.clone().add(up.clone().multiplyScalar(600)));
                tower.lookAt(worldPos);
                scene.add(tower);
            }
        }
    }
    pos.needsUpdate = true;
    geo.computeVertexNormals();
    geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({vertexColors:true, roughness:0.95, metalness:0.05}));
    return {mesh, radius};
}

const BRASIL_RADIUS = 120000;
const brasil = createPlanet(BRASIL_RADIUS, 220, true, 'diverse');
scene.add(brasil.mesh);

const otherPlanets = [];
const planetTypes = ['ice', 'desert', 'blue', 'diverse'];
for (let i = 0; i < 40; i++) {
    const scale = 6 + Math.random() * 16;
    const radius = (800 + Math.random()*400) * scale * 10;
    const typeIndex = Math.floor(Math.random() * planetTypes.length);
    const planetType = planetTypes[typeIndex];
    const planet = createPlanet(radius, Math.min(200, 60 + Math.floor(scale*9)), false, planetType);
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const dist = 2000000 + Math.random() * 6000000;
    planet.mesh.position.set(dist * Math.sin(phi) * Math.cos(theta), dist * Math.sin(phi) * Math.sin(theta), dist * Math.cos(phi));
    scene.add(planet.mesh);
    otherPlanets.push({mesh: planet.mesh, radius});
}

const aircraft = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({color: 0x1c2526, metalness: 0.8, roughness: 0.3});
const wingShape = new THREE.Shape();
wingShape.moveTo(0,0); wingShape.lineTo(55,0); wingShape.lineTo(30,60);
wingShape.lineTo(-30,60); wingShape.lineTo(-55,0);
const wings = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape, {depth: 0.8, bevelEnabled: true}), mat);
wings.rotation.x = -Math.PI/2; wings.position.y = -1; aircraft.add(wings);

const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 12, 18), mat);
tail.position.set(0, 1.5, -28);
const tailL = tail.clone(); tailL.rotation.z = Math.PI/5; tailL.position.x = -4;
const tailR = tail.clone(); tailR.rotation.z = -Math.PI/5; tailR.position.x = 4;
aircraft.add(tailL, tailR);

const cockpit = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 12), new THREE.MeshStandardMaterial({color: 0x050505, metalness: 1}));
cockpit.scale.set(1.5, 0.8, 2.2); cockpit.position.set(0, 3, 10); aircraft.add(cockpit);

const ab = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12, 1, true),
    new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0, blending: THREE.AdditiveBlending}));
ab.position.set(0, -1.5, -25); aircraft.add(ab);

const flameGeo = new THREE.BufferGeometry();
const flamePos = new Float32Array(2400);
for(let i=0;i<2400;i+=3){
    flamePos[i] = (Math.random()-0.5)*6;
    flamePos[i+1] = -1.5 + (Math.random()-0.5)*2;
    flamePos[i+2] = -25 + (Math.random()-0.5)*10;
}
flameGeo.setAttribute('position', new THREE.BufferAttribute(flamePos, 3));
const flame = new THREE.Points(flameGeo, new THREE.PointsMaterial({color:0xff9500, size:5, blending:THREE.AdditiveBlending, transparent:true, depthWrite:false}));
aircraft.add(flame); flame.visible = false;

// PARTICULAS DE WARP
const warpParticles = new THREE.Points(
    new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(800*3), 3)),
    new THREE.PointsMaterial({color:0x00aaff, size:10, blending:THREE.AdditiveBlending, transparent:true})
);
const warpPos = warpParticles.geometry.attributes.position.array;
for(let i=0;i<2400;i+=3){
    warpPos[i] = (Math.random()-0.5)*200;
    warpPos[i+1] = (Math.random()-0.5)*200;
    warpPos[i+2] = -50 - Math.random()*100;
}
scene.add(warpParticles);
warpParticles.visible = false;

// OUTRAS NAVES
const otherShips = [];
for (let i = 0; i < 10; i++) {
    const ship = aircraft.clone();
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const r = 500000 + Math.random() * 2000000;
    ship.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
    ship.scale.set(1.5, 1.5, 1.5);
    scene.add(ship);
    otherShips.push(ship);
}

scene.add(aircraft);

const portals = [];
for(let i=0;i<6;i++){
    const angle = i/6*Math.PI*2;
    const pos = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).multiplyScalar(BRASIL_RADIUS + 2000);
    const dest = new THREE.Vector3(Math.cos(angle + Math.PI), 0, Math.sin(angle + Math.PI)).multiplyScalar(BRASIL_RADIUS + 2000);
    const ring = new THREE.Mesh(new THREE.TorusGeometry(600, 80, 20, 60), new THREE.MeshBasicMaterial({color:0x00ff44, transparent:true, opacity:0.9, blending:THREE.AdditiveBlending}));
    ring.position.copy(pos);
    ring.lookAt(0,0,0);
    ring.rotateX(Math.PI/2);
    scene.add(ring);
    portals.push({pos, dest, mesh:ring, newTime:i/6});
}

const state = {
    pos: new THREE.Vector3(0, BRASIL_RADIUS + 3000, 0),
    vel: new THREE.Vector3(180, 0, 0),
    rot: {pitch:0, roll:0, yaw:0},
    rotVel: {pitch:0, roll:0, yaw:0},
    throttle: 0.5,
    fuel: 1.0,
    crashed: false,
    mass: 24000,
    wingArea: 105,
    thrustMax: 120000,
    warp: false
};

aircraft.position.copy(state.pos);

const keys = {};
window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true);
window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

const clock = new THREE.Clock();
let timeOfDay = 0;
let warpCountdown = 0;
let warpDuration = 0;
let isCountingDown = false;
let preWarpPos = new THREE.Vector3();
const countdownDiv = document.getElementById('warp-countdown');

function animate(){
    const dt = Math.min(clock.getDelta(), 0.033);
    timeOfDay = (timeOfDay + dt/480) % 1;
    const angle = timeOfDay * Math.PI * 2;
    const sunY = Math.sin(angle) * 300000;
    sun.position.set(Math.cos(angle)*300000, sunY, Math.sin(angle)*300000);
    const intensity = Math.max(0, sunY / 300000);
    sun.intensity = intensity * 3;
    ambientLight.intensity = 0.3 + intensity * 0.7;
    scene.background = new THREE.Color().setHSL(0.58, 0.6, intensity * 0.5 + 0.1);
    stars.visible = intensity < 0.3;
    scene.fog.density = intensity < 0.3 ? 0.000010 : 0.000025;

    const h = Math.floor(timeOfDay*24)%24;
    const m = Math.floor(timeOfDay*1440)%60;
    document.getElementById('hora').textContent = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;

    if(keys['c']) state.vel.add(new THREE.Vector3(0,0,-1).applyQuaternion(aircraft.quaternion).multiplyScalar(1800*dt));
    if(keys['x']) state.vel.add(new THREE.Vector3(0,1,0).applyQuaternion(aircraft.quaternion).multiplyScalar(3000*dt));
    if(keys[' ']){
        state.pos = new THREE.Vector3(0, BRASIL_RADIUS + 3000, 0);
        state.vel.set(180,0,0);
        state.rot = {pitch:0,roll:0,yaw:0};
        state.rotVel = {pitch:0,roll:0,yaw:0};
        state.throttle = 0.5;
        state.fuel = 1.0;
        state.crashed = false;
    }

    const inputThr = (keys['w']?1:0) - (keys['s']?1:0);
    const inputYaw = (keys['a']?1:0) - (keys['d']?1:0);
    const inputRoll = (keys['e']?1:0) - (keys['q']?1:0);
    const inputPitch = (keys['arrowup']?1:0) - (keys['arrowdown']?1:0);

    state.throttle = THREE.MathUtils.clamp(state.throttle + inputThr*dt*0.8, 0, 1);
    state.fuel = Math.max(0, state.fuel - state.throttle*dt*0.00008);

    state.rotVel.pitch += inputPitch*3*dt;
    state.rotVel.roll += inputRoll*3.5*dt;
    state.rotVel.yaw += inputYaw*2*dt;
    state.rotVel.pitch *= 0.98; state.rotVel.roll *= 0.98; state.rotVel.yaw *= 0.94;

    state.rot.pitch += state.rotVel.pitch*dt;
    state.rot.roll += state.rotVel.roll*dt;
    state.rot.yaw += state.rotVel.yaw*dt;
    state.rot.pitch = THREE.MathUtils.clamp(state.rot.pitch, -1.4, 1.2);

    const euler = new THREE.Euler(state.rot.pitch, state.rot.yaw, state.rot.roll, 'YXZ');
    aircraft.quaternion.setFromEuler(euler);
    aircraft.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), Math.PI));

    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(aircraft.quaternion);
    const up = new THREE.Vector3(0,1,0).applyQuaternion(aircraft.quaternion);

    let accel = new THREE.Vector3(0,0,0); // será calculado de forma diferente no warp

    // ==================== MODO WARP COM CONTAGEM E DURAÇÃO LIMITADA ====================
    if (keys['z'] && !isCountingDown && !state.warp) {
        isCountingDown = true;
        warpCountdown = 3;
        countdownDiv.style.display = 'block';
        countdownDiv.textContent = 'WARP: 3';
        preWarpPos.copy(state.pos);
    }

    if (isCountingDown) {
        warpCountdown -= dt;
        countdownDiv.textContent = `WARP: ${Math.ceil(warpCountdown)}`;
        if (warpCountdown <= 0) {
            isCountingDown = false;
            countdownDiv.style.display = 'none';
            state.warp = true;
            warpDuration = 2;
        }
    }

    if (state.warp) {
        warpDuration -= dt;

        // Impulso direto brutal na direção da nave – sem nenhum freio
        const warpImpulse = forward.clone().multiplyScalar(12000000 * dt); // velocidade absurda
        state.vel.add(warpImpulse);
        state.vel.setLength(Math.min(state.vel.length(), 80000)); // limite para não infinito

        // Consumo de combustível um pouco maior
        state.fuel -= dt * 0.0003;

        // Partículas de warp mais rápidas
        warpParticles.visible = true;
        warpParticles.position.copy(state.pos);
        warpParticles.quaternion.copy(aircraft.quaternion);
        const wp = warpParticles.geometry.attributes.position.array;
        for(let i=0;i<wp.length;i+=3){
            wp[i+2] -= 15000*dt;
            if(wp[i+2] < -300){
                wp[i] = (Math.random()-0.5)*500;
                wp[i+1] = (Math.random()-0.5)*500;
                wp[i+2] = -50;
            }
        }
        warpParticles.geometry.attributes.position.needsUpdate = true;

        // HUD mostra que estamos fora da realidade
        document.getElementById('vel').textContent = (state.vel.length()*3.6*100).toFixed(1) + "c";
        document.getElementById('g').textContent = "∞";
        document.getElementById('alt').textContent = "ESPAÇO LIVRE";

        if (warpDuration <= 0) {
            state.warp = false;
            warpParticles.visible = false;
            // Frear e voltar à velocidade inicial
            state.vel.copy(forward.clone().multiplyScalar(180));
            // Posicionar próximo ao planeta mais próximo da posição pré-warp a 5000m de altitude
            let closestPlanet = null;
            let minDist = Infinity;
            otherPlanets.forEach(p => {
                const dist = preWarpPos.distanceTo(p.mesh.position);
                if (dist < minDist && dist > 0) { // evitar o mesmo planeta, se for o caso
                    minDist = dist;
                    closestPlanet = p;
                }
            });
            if (closestPlanet) {
                const direction = preWarpPos.clone().sub(closestPlanet.mesh.position).normalize();
                state.pos.copy(closestPlanet.mesh.position.clone().add(direction.multiplyScalar(closestPlanet.radius + 5000)));
            }
        }
    } else if (!isCountingDown) {
        // FÍSICA NORMAL (exatamente como era antes)
        const speed = state.vel.length();
        accel = forward.clone().multiplyScalar(state.thrustMax * state.throttle * state.fuel / state.mass);

        const drag = 0.5 * 1.225 * speed*speed * 0.04 * state.wingArea;
        accel.add(state.vel.clone().normalize().multiplyScalar(-drag/state.mass));

        const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));
        const lift = 0.5 * 1.225 * speed*speed * 2 * state.wingArea * Math.sin(aoa);
        accel.add(up.clone().multiplyScalar(lift/state.mass));

        // Gravidade do planeta
        accel.add(state.pos.clone().normalize().multiplyScalar(-9.81 * (BRASIL_RADIUS / state.pos.length())**2));

        state.vel.add(accel.multiplyScalar(dt));
        state.vel.setLength(Math.min(state.vel.length(), 800)); // limite normal mantido
    }

    // Atualização comum (warp ou não)
    state.vel.add(accel.multiplyScalar(dt)); // só tem efeito fora do warp
    state.pos.add(state.vel.clone().multiplyScalar(dt));

    // Colisão com planeta e outros planetas (só fora do warp)
    if (!state.warp) {
        const altitude = state.pos.length() - BRASIL_RADIUS;
        if(altitude < 100){
            state.pos.normalize().multiplyScalar(BRASIL_RADIUS + 100);
            if(state.vel.length() > 120) state.crashed = true;
        }
        otherPlanets.forEach(p => {
            const d = state.pos.distanceTo(p.mesh.position);
            if (d < p.radius + 200) {
                const normal = state.pos.clone().sub(p.mesh.position).normalize();
                state.pos = p.mesh.position.clone().add(normal.multiplyScalar(p.radius + 200));
                if (state.vel.length() > 120) state.crashed = true;
            }
        });
    }

    aircraft.position.copy(state.pos);

    const camOffset = new THREE.Vector3(0, 90, 300).applyQuaternion(aircraft.quaternion);
    camera.position.lerp(state.pos.clone().add(camOffset), 0.1);
    camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(300)));

    ab.material.opacity = state.throttle > 0.6 ? (state.throttle-0.6)*2.5 : 0;
    flame.visible = state.throttle > 0.72 || keys['c'];
    if(flame.visible){
        const p = flame.geometry.attributes.position.array;
        for(let i=0;i<p.length;i+=3){
            p[i+2] -= 3000*dt;
            if(p[i+2] < -100) p[i+2] = -20;
        }
        flame.geometry.attributes.position.needsUpdate = true;
    }

    portals.forEach(p=>{
        p.mesh.rotation.z += dt*1.5;
        if(state.pos.distanceTo(p.pos) < 800){
            state.pos.copy(p.dest);
            timeOfDay = p.newTime;
        }
    });

    // HUD normal (só fora do warp)
    if (!state.warp) {
        const altitude = state.pos.length() - BRASIL_RADIUS;
        const speed = state.vel.length();
        const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));

        document.getElementById('alt').textContent = Math.round(altitude);
        document.getElementById('vel').textContent = Math.round(speed*3.6);
        document.getElementById('aoa').textContent = THREE.MathUtils.radToDeg(aoa).toFixed(1);
        document.getElementById('g').textContent = (accel.length()/9.81 + 1).toFixed(1);
    }

    document.getElementById('thr').textContent = Math.round(state.throttle*100);
    document.getElementById('pitch').textContent = THREE.MathUtils.radToDeg(state.rot.pitch).toFixed(1);
    document.getElementById('roll').textContent = THREE.MathUtils.radToDeg(state.rot.roll).toFixed(1);
    document.getElementById('fuel').textContent = Math.round(state.fuel*100);
    document.getElementById('stat').textContent = state.crashed?'CRASHED':'FLYING';

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

window.addEventListener('resize',()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
