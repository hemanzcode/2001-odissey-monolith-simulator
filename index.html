<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2001 Odyssey Monolith Travel - Brasil Edition ULTRA</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body { margin:0; overflow:hidden; background:#000; }
        canvas { display:block; }
        #hud, #status, #gforce, #controls {
            position:fixed; color:#0f8; background:rgba(0,0,0,0.88);
            padding:12px 16px; border:1px solid #0f8; border-radius:6px;
            font-size:11px; line-height:1.5; z-index:100; text-transform:uppercase; letter-spacing:2px;
        }
        #hud { left:20px; top:20px; }
        #status { right:20px; top:20px; }
        #gforce { left:20px; top:200px; color:#ff0; border:1px solid #ff0; font-size:15px; font-weight:bold; letter-spacing:3px; }
        #controls { bottom:30px; right:20px; color:#0f8; }
        .label { font-family: 'Orbitron', sans-serif; font-weight: 700; color: #0ff; text-shadow: 0 0 8px #0ff; letter-spacing: 3px; font-size: 12px; }
        #gforce { font-family: 'Orbitron', sans-serif; text-shadow: 0 0 10px #ff0; }
    </style>
</head>
<body>
<div id="hud">
    <div><span class="label">ALTITUDE</span>: <span id="alt">1000</span>m</div>
    <div><span class="label">VELOCIDADE</span>: <span id="vel">300</span> km/h</div>
    <div><span class="label">PITCH</span>: <span id="pitch">0</span>°</div>
    <div><span class="label">ROLL</span>: <span id="roll">0</span>°</div>
    <div><span class="label">AOA</span>: <span id="aoa">0</span>°</div>
</div>
<div id="status">
    <div><span class="label">THROTTLE</span>: <span id="thr">50</span>%</div>
    <div><span class="label">FUEL</span>: <span id="fuel">100</span>%</div>
    <div><span class="label">HORA</span>: <span id="hora">12:00</span></div>
    <div><span class="label">STATUS</span>: <span id="stat">FLYING</span></div>
</div>
<div id="gforce">G-FORCE: <span id="g">1.0</span>G</div>
<div id="controls">
    W/S=Throttle D=ESQ A=DIR Q/E=Roll ↑↓=Pitch X=SUBIR C=TURBO<br>
    <span style="color:#0f0; font-size:14px;">STARGATES VERDES GIGANTES → muda lugar + hora do dia!</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x87ceeb, 0.00008);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 200000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
scene.add(ambientLight);
const sun = new THREE.DirectionalLight(0xffffe0, 1.5);
sun.position.set(10000, 10000, 5000);
sun.castShadow = true;
scene.add(sun);

// ==================== ESTRELAS ====================
const starGeo = new THREE.BufferGeometry();
const starPositions = [];
for (let i = 0; i < 5000; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.random() * Math.PI;
    const r = 80000;
    starPositions.push(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
    );
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 80}));
scene.add(stars);

// ==================== NUVENS ====================
const clouds = [];
for (let i = 0; i < 80; i++) {
    const cloud = new THREE.Mesh(
        new THREE.SphereGeometry(400 + Math.random() * 300, 8, 8),
        new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.4})
    );
    cloud.position.set(
        (Math.random() - 0.5) * 120000,
        3000 + Math.random() * 2000,
        (Math.random() - 0.5) * 120000
    );
    cloud.scale.set(1, 0.3, 1);
    scene.add(cloud);
    clouds.push({mesh: cloud, speed: 5 + Math.random() * 10});
}

// ==================== CHUVA ====================
const rainGeo = new THREE.BufferGeometry();
const rainPositions = [];
for (let i = 0; i < 8000; i++) {
    rainPositions.push(
        (Math.random() - 0.5) * 6000,
        Math.random() * 5000,
        (Math.random() - 0.5) * 6000
    );
}
rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPositions, 3));
const rain = new THREE.Points(rainGeo, new THREE.PointsMaterial({
    color: 0x88aaff, size: 3, transparent: true, opacity: 0.6
}));
rain.visible = false;
scene.add(rain);

let timeOfDay = 0;
const cycleDuration = 480;

// ==================== STARGATES VERDES GIGANTES (mais portais!) ====================
const portals = [
    { pos: new THREE.Vector3(0, 1400, -12000),    dest: new THREE.Vector3(60000, 2500, 40000), newTime: 0.0 },
    { pos: new THREE.Vector3(60000, 2500, 40000), dest: new THREE.Vector3(-70000, 3000, -80000), newTime: 0.5 },
    { pos: new THREE.Vector3(-70000, 3000, -80000), dest: new THREE.Vector3(0, 1200, 0), newTime: 0.75 },
    { pos: new THREE.Vector3(35000, 2200, -25000), dest: new THREE.Vector3(-40000, 1800, 55000), newTime: 0.25 },
    { pos: new THREE.Vector3(-40000, 1800, 55000), dest: new THREE.Vector3(85000, 2800, -15000), newTime: 0.65 },
    { pos: new THREE.Vector3(85000, 2800, -15000), dest: new THREE.Vector3(-25000, 2400, -45000), newTime: 0.85 }
];

portals.forEach(p => {
    const ring = new THREE.Mesh(
        new THREE.TorusGeometry(200, 30, 20, 60),
        new THREE.MeshBasicMaterial({color: 0x00ff44, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending})
    );
    ring.rotation.x = -Math.PI/2;
    ring.position.copy(p.pos);
    scene.add(ring);
    p.mesh = ring;
});

// ==================== TERRENO BRASIL ====================
class BrasilTerrain {
    constructor() { this.chunks = new Map(); this.size = 2500; }
    getBiome(x, z) {
        const lon = x * 0.00002; const lat = z * 0.00002;
        if (lat > 0.1 && Math.abs(lon) < 0.4) return {color: 0x003300, name: "amazonia"};
        if (Math.abs(lat) < 0.3 && Math.abs(lon) < 0.35) return {color: 0x8B6914, name: "cerrado"};
        if (lat > -0.1 && lat < 0.15 && lon > -0.3 && lon < -0.15) return {color: 0x2E8B57, name: "pantanal"};
        if (lon > 0.2) return {color: 0x006400, name: "mata_atlantica"};
        if (lat > 0.2 && lon > 0.1) return {color: 0xD2B48C, name: "caatinga"};
        if (lat < -0.3) return {color: 0x228B22, name: "pampas"};
        if (this.noise(x*0.002, z*0.002) > 0.88) return {color: 0x006994, name: "agua"};
        return {color: 0x228B22, name: "grama"};
    }
    noise(x, z) {
        return Math.sin(x*0.0008)*Math.cos(z*0.0008)*0.5 +
               Math.sin(x*0.0015 + 123)*0.3 +
               Math.sin(z*0.002 + 456)*0.2;
    }
    getHeight(x, z) {
        const n = this.noise(x, z);
        const base = 180 + n * 600;
        const serras = Math.max(0, this.noise(x*0.0004, z*0.0004) - 0.2) * 5000;
        return base + serras;
    }
    addPalmTree(x, y, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.5, 14, 8), new THREE.MeshStandardMaterial({color:0x8B4513}));
        trunk.position.set(x, y+7, z);
        const leaves = new THREE.Mesh(new THREE.SphereGeometry(9, 8, 6), new THREE.MeshStandardMaterial({color:0x006400}));
        leaves.scale.y = 0.4; leaves.position.set(x, y+18, z);
        scene.add(trunk, leaves);
    }
    addPyramid(x, y, z) {
        const pyr = new THREE.Mesh(new THREE.ConeGeometry(10, 16, 4), new THREE.MeshStandardMaterial({color:0x222222}));
        pyr.rotation.y = Math.PI/4; pyr.position.set(x, y+8, z);
        scene.add(pyr);
    }
    addMountainTree(x, y, z) {
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 3.5, 16, 8), new THREE.MeshStandardMaterial({color:0x654321}));
        trunk.position.set(x, y+8, z);
        const top = new THREE.Mesh(new THREE.ConeGeometry(10, 20, 8), new THREE.MeshStandardMaterial({color:0x003300}));
        top.position.set(x, y+22, z);
        scene.add(trunk, top);
    }
    addHouse(x, y, z) {
        const base = new THREE.Mesh(new THREE.BoxGeometry(12, 8, 12), new THREE.MeshStandardMaterial({color:0xd4a574}));
        base.position.set(x, y+4, z);
        const roof = new THREE.Mesh(new THREE.ConeGeometry(9, 6, 4), new THREE.MeshStandardMaterial({color:0x8b4513}));
        roof.rotation.y = Math.PI/4; roof.position.set(x, y+11, z);
        scene.add(base, roof);
    }
    addRiver(x, y, z) {
        const river = new THREE.Mesh(
            new THREE.PlaneGeometry(30, 200),
            new THREE.MeshStandardMaterial({color:0x4682b4, transparent:true, opacity:0.7, metalness:0.9, roughness:0.1})
        );
        river.rotation.x = -Math.PI/2;
        river.position.set(x, y+1, z);
        scene.add(river);
    }
    createChunk(gx, gz) {
        const key = `${gx},${gz}`;
        if (this.chunks.has(key)) return;
        const geo = new THREE.PlaneGeometry(this.size, this.size, 128, 128);
        const pos = geo.attributes.position;
        const colors = [];
        for (let i = 0; i < pos.count; i++) {
            const x = pos.getX(i) + gx * this.size;
            const z = pos.getY(i) + gz * this.size;
            const h = this.getHeight(x, z);
            pos.setZ(i, h);
            const biome = this.getBiome(x, z);
            colors.push((biome.color>>16&255)/255, (biome.color>>8&255)/255, (biome.color&255)/255);
            if (i % 1000 === 0) {
                if (biome.name === "caatinga") {
                    if (Math.random() < 0.25) this.addPalmTree(x, h, z);
                    if (Math.random() < 0.07) this.addPyramid(x, h, z);
                }
                else if (h > 800 && Math.random() < 0.35) this.addMountainTree(x, h, z);
            }
            if (i % 500 === 0 && Math.random() < 0.15) this.addPalmTree(x, h, z);
            if (i % 800 === 0 && Math.random() < 0.08) this.addMountainTree(x, h, z);
            if (i % 1200 === 0 && Math.random() < 0.05) this.addHouse(x, h, z);
            if (i % 2000 === 0 && Math.random() < 0.1 && biome.name === "agua") this.addRiver(x, h, z);
        }
        pos.needsUpdate = true;
        geo.computeVertexNormals();
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({vertexColors: true, roughness: 0.9, metalness: 0.05}));
        mesh.rotation.x = -Math.PI/2;
        mesh.position.set(gx*this.size, 0, gz*this.size);
        mesh.receiveShadow = true;
        scene.add(mesh);
        this.chunks.set(key, mesh);
    }
    update(pos) {
        const cx = Math.floor(pos.x / this.size);
        const cz = Math.floor(pos.z / this.size);
        for (let x = cx-3; x <= cx+3; x++)
            for (let z = cz-3; z <= cz+3; z++)
                this.createChunk(x, z);
        for (const [k,m] of this.chunks.entries()) {
            const [x,z] = k.split(',').map(Number);
            if (Math.abs(x-cx)>4 || Math.abs(z-cz)>4) {
                scene.remove(m); m.geometry.dispose(); m.material.dispose(); this.chunks.delete(k);
            }
        }
    }
    getHeightAt(x, z) { return this.getHeight(x, z); }
}
const terrain = new BrasilTerrain();

// ==================== AERONAVE DO JOGADOR ====================
const aircraft = new THREE.Group();
const mat = new THREE.MeshStandardMaterial({color: 0x1c2526, metalness: 0.8, roughness: 0.3});
const wingShape = new THREE.Shape();
wingShape.moveTo(0,0); wingShape.lineTo(55,0); wingShape.lineTo(30,60);
wingShape.lineTo(-30,60); wingShape.lineTo(-55,0);
const wings = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape, {depth: 0.8, bevelEnabled: true, bevelSize: 0.4}), mat);
wings.rotation.x = -Math.PI/2; wings.position.y = -1; aircraft.add(wings);
const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 12, 18), mat);
tail.position.set(0, 1.5, -28);
const tailL = tail.clone(); tailL.rotation.z = Math.PI/5; tailL.position.x = -4;
const tailR = tail.clone(); tailR.rotation.z = -Math.PI/5; tailR.position.x = 4;
aircraft.add(tailL, tailR);
const cockpit = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 12), new THREE.MeshStandardMaterial({color: 0x050505, metalness: 1}));
cockpit.scale.set(1.5, 0.8, 2.2); cockpit.position.set(0, 3, 10); aircraft.add(cockpit);
const ab = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12, 1, true),
    new THREE.MeshBasicMaterial({color: 0xffaa00, transparent: true, opacity: 0, blending: THREE.AdditiveBlending}));
ab.position.set(0, -1.5, -25); aircraft.add(ab);
const particleCount = 800;
const positions = new Float32Array(particleCount * 3);
for (let i = 0; i < particleCount * 3; i += 3) {
    positions[i] = (Math.random() - 0.5) * 6;
    positions[i+1] = -1.5 + (Math.random() - 0.5) * 2;
    positions[i+2] = -25 + (Math.random() - 0.5) * 10;
}
const flameGeo = new THREE.BufferGeometry();
flameGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
const flame = new THREE.Points(flameGeo, new THREE.PointsMaterial({
    color: 0xff9500, size: 5, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false
}));
aircraft.add(flame); flame.visible = false;
aircraft.position.set(0, 1200, 0);
scene.add(aircraft);

// ==================== AERONAVES NO CÉU ====================
const otherAircraft = [];
for (let i = 0; i < 12; i++) {
    const plane = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 15), new THREE.MeshStandardMaterial({color:0xcccccc}));
    plane.add(body);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(30, 0.5, 6), new THREE.MeshStandardMaterial({color:0xaaaaaa}));
    wing.position.y = -1;
    plane.add(wing);
    
    plane.position.set(
        (Math.random() - 0.5) * 80000,
        2000 + Math.random() * 3000,
        (Math.random() - 0.5) * 80000
    );
    
    const angle = Math.random() * Math.PI * 2;
    plane.rotation.y = angle;
    
    scene.add(plane);
    otherAircraft.push({
        mesh: plane,
        speed: 100 + Math.random() * 150,
        direction: new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)),
        altitude: plane.position.y
    });
}

// ==================== ESTADO DA AERONAVE ====================
const state = {
    pos: new THREE.Vector3(0, 1200, 0),
    vel: new THREE.Vector3(83, 0, 0),
    rot: {pitch: 0, roll: 0, yaw: 0},
    rotVel: {pitch: 0, roll: 0, yaw: 0},
    throttle: 0.5,
    fuel: 1.0,
    crashed: false,
    mass: 24000,
    wingArea: 105,
    thrustMax: 2 * 48000
};

const keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' ') e.preventDefault(); });
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
const clock = new THREE.Clock();

function animate() {
    const dt = Math.min(clock.getDelta(), 0.033);

    // CICLO DIA/NOITE (com transições suaves de cores)
    timeOfDay += dt / cycleDuration;
    if (timeOfDay > 1) timeOfDay -= 1;
    const angle = timeOfDay * Math.PI * 2;
    const sunY = Math.sin(angle) * 12000;
    sun.position.set(Math.cos(angle)*15000, sunY, Math.sin(angle)*15000);
    
    // Intensidade do sol
    const intensity = Math.max(0, sunY / 12000);
    sun.intensity = intensity * 2;
    ambientLight.intensity = 0.3 + intensity * 0.7;
    
    // Cores do céu com transições suaves
    let skyColor, fogDensity, sunColor;
    
    if (timeOfDay < 0.25) { // Noite (0h - 6h)
        skyColor = new THREE.Color(0x000511);
        fogDensity = 0.00004;
        sunColor = 0x6666ff;
        stars.visible = true;
    } else if (timeOfDay < 0.35) { // Amanhecer (6h - 8h30)
        const t = (timeOfDay - 0.25) / 0.1;
        skyColor = new THREE.Color().lerpColors(new THREE.Color(0x000511), new THREE.Color(0xff8844), t);
        fogDensity = 0.00004 + t * 0.00004;
        sunColor = 0xffaa44;
        stars.visible = t < 0.5;
    } else if (timeOfDay < 0.5) { // Manhã (8h30 - 12h)
        const t = (timeOfDay - 0.35) / 0.15;
        skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff8844), new THREE.Color(0x87ceeb), t);
        fogDensity = 0.00008;
        sunColor = 0xffffe0;
        stars.visible = false;
    } else if (timeOfDay < 0.65) { // Tarde (12h - 15h30)
        skyColor = new THREE.Color(0x87ceeb);
        fogDensity = 0.00008;
        sunColor = 0xffffe0;
        stars.visible = false;
    } else if (timeOfDay < 0.75) { // Entardecer (15h30 - 18h)
        const t = (timeOfDay - 0.65) / 0.1;
        skyColor = new THREE.Color().lerpColors(new THREE.Color(0x87ceeb), new THREE.Color(0xff6622), t);
        fogDensity = 0.00008;
        sunColor = 0xff8844;
        stars.visible = false;
    } else { // Anoitecer (18h - 0h)
        const t = (timeOfDay - 0.75) / 0.25;
        skyColor = new THREE.Color().lerpColors(new THREE.Color(0xff6622), new THREE.Color(0x000511), t);
        fogDensity = 0.00008 - t * 0.00004;
        sunColor = 0x4444aa;
        stars.visible = t > 0.3;
    }
    
    scene.background = skyColor;
    scene.fog.density = fogDensity;
    sun.color.setHex(sunColor);
    
    // Chuva aleatória
    if (Math.random() < 0.002) {
        rain.visible = !rain.visible;
    }

    // HORA NO HUD
    const horas = Math.floor(timeOfDay * 24) % 24;
    const minutos = Math.floor((timeOfDay * 24 * 60) % 60);
    document.getElementById('hora').textContent = `${horas.toString().padStart(2,'0')}:${minutos.toString().padStart(2,'0')}`;

    // PORTAL: muda posição + hora do dia
    for (const portal of portals) {
        if (state.pos.distanceTo(portal.pos) < 700) {
            state.pos.copy(portal.dest);
            timeOfDay = portal.newTime;
            state.vel.multiplyScalar(0.4);
            aircraft.position.copy(state.pos);
            break;
        }
    }

    // CONTROLES
    if (keys['c']) {
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
        state.vel.add(forward.multiplyScalar(600 * dt));
    }
    if (keys['x']) state.pos.y += 1000 * dt;

    const inputThr   = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
    const inputYaw   = (keys['a'] ? 1 : 0) - (keys['d'] ? 1 : 0);
    const inputRoll  = (keys['e'] ? 1 : 0) - (keys['q'] ? 1 : 0);
    const inputPitch = (keys['arrowup'] ? 1 : 0) - (keys['arrowdown'] ? 1 : 0);

    if (keys[' ']) {
        state.pos.set(0, 1200, 0);
        state.vel.set(83, 0, 0);
        state.rot = {pitch:0, roll:0, yaw:0};
        state.rotVel = {pitch:0, roll:0, yaw:0};
        state.throttle = 0.5;
        state.fuel = 1.0;
        state.crashed = false;
    }

    state.throttle = THREE.MathUtils.clamp(state.throttle + inputThr * dt * 0.6, 0, 1);
    state.fuel = Math.max(0, state.fuel - state.throttle * dt * 0.00008);
    ab.material.opacity = state.throttle > 0.6 ? (state.throttle - 0.6) * 2.5 : 0;

    state.rotVel.pitch += inputPitch * 2.8 * dt;
    state.rotVel.roll  += inputRoll  * 3.0 * dt;
    state.rotVel.yaw   += inputYaw   * 1.8 * dt;
    state.rotVel.pitch *= 0.98; state.rotVel.roll *= 0.98; state.rotVel.yaw *= 0.94;
    state.rot.pitch += state.rotVel.pitch * dt;
    state.rot.roll  += state.rotVel.roll  * dt;
    state.rot.yaw   += state.rotVel.yaw   * dt;
    state.rot.pitch = THREE.MathUtils.clamp(state.rot.pitch, -1.4, 1.2);

    const quat = new THREE.Quaternion();
    const euler = new THREE.Euler(state.rot.pitch, state.rot.yaw, state.rot.roll, 'YXZ');
    quat.setFromEuler(euler);
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), THREE.MathUtils.degToRad(5)));
    quat.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI));

    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(quat);
    const up = new THREE.Vector3(0, 1, 0).applyQuaternion(quat);
    const speed = state.vel.length();
    const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));

    let accel = forward.clone().multiplyScalar(state.thrustMax * state.throttle * state.fuel / state.mass);
    const drag = 0.5 * 1.225 * speed * speed * 0.04 * state.wingArea;
    accel.add(state.vel.clone().normalize().multiplyScalar(-drag / state.mass));
    const lift = 0.5 * 1.225 * speed * speed * 2.0 * state.wingArea * Math.sin(aoa);
    accel.add(up.clone().multiplyScalar(lift / state.mass));
    accel.y -= 9.81;
    state.vel.add(accel.multiplyScalar(dt));
    state.vel.setLength(Math.min(state.vel.length(), 380));
    state.pos.add(state.vel.clone().multiplyScalar(dt));

    const ground = terrain.getHeightAt(state.pos.x, state.pos.z);
    if (state.pos.y < ground + 50) {
        if (!state.crashed && state.vel.y < -15) state.crashed = true;
        state.pos.y = ground + 50;
        state.vel.y = Math.max(state.vel.y, 0);
    }

    aircraft.position.copy(state.pos);
    aircraft.quaternion.copy(quat);
    terrain.update(state.pos);
    portals.forEach(p => p.mesh.rotation.z += dt * 0.6);
    
    // Movimento das nuvens
    clouds.forEach(c => {
        c.mesh.position.x += c.speed * dt;
        if (c.mesh.position.x > 60000) c.mesh.position.x = -60000;
    });
    
    // Movimento da chuva
    if (rain.visible) {
        const rainPos = rain.geometry.attributes.position;
        for (let i = 0; i < rainPos.count * 3; i += 3) {
            rainPos.array[i+1] -= 1500 * dt;
            if (rainPos.array[i+1] < 0) rainPos.array[i+1] = 5000;
        }
        rainPos.needsUpdate = true;
        rain.position.set(state.pos.x, 0, state.pos.z);
    }
    
    // Movimento das aeronaves
    otherAircraft.forEach(p => {
        p.mesh.position.x += p.direction.x * p.speed * dt;
        p.mesh.position.z += p.direction.z * p.speed * dt;
        p.mesh.position.y = p.altitude + Math.sin(Date.now() * 0.0005 + p.mesh.position.x * 0.001) * 50;
        
        if (Math.abs(p.mesh.position.x) > 100000 || Math.abs(p.mesh.position.z) > 100000) {
            const newAngle = Math.random() * Math.PI * 2;
            p.mesh.position.set(state.pos.x + (Math.random() - 0.5) * 10000, p.altitude, state.pos.z + (Math.random() - 0.5) * 10000);
            p.mesh.rotation.y = newAngle;
            p.direction.set(Math.cos(newAngle), 0, Math.sin(newAngle));
        }
    });

    const camOffset = new THREE.Vector3(0, 80, 250).applyQuaternion(quat);
    camera.position.lerp(state.pos.clone().add(camOffset), 0.1);
    camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(200)));

    flame.visible = state.throttle > 0.72 || keys['c'];
    if (flame.visible) {
        const pos = flame.geometry.attributes.position.array;
        for (let i = 0; i < pos.length; i += 3) {
            pos[i+2] -= 1200 * dt;
            if (pos[i+2] < -70) pos[i+2] = -20;
        }
        flame.geometry.attributes.position.needsUpdate = true;
    }

    document.getElementById('alt').textContent = Math.round(state.pos.y - ground);
    document.getElementById('vel').textContent = Math.round(speed * 3.6);
    document.getElementById('thr').textContent = Math.round(state.throttle * 100);
    document.getElementById('aoa').textContent = THREE.MathUtils.radToDeg(aoa).toFixed(1);
    document.getElementById('pitch').textContent = THREE.MathUtils.radToDeg(state.rot.pitch).toFixed(1);
    document.getElementById('roll').textContent = THREE.MathUtils.radToDeg(state.rot.roll).toFixed(1);
    document.getElementById('fuel').textContent = Math.round(state.fuel * 100);
    document.getElementById('stat').textContent = state.crashed ? 'CRASHED' : 'FLYING';
    document.getElementById('g').textContent = (accel.length() / 9.81 + 1).toFixed(1);

    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});

animate();
</script>
</body>
</html>
