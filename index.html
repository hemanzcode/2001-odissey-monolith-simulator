<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2001 Odyssey Monolith Travel - WARP DRIVE ATIVADO</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }

        #hud,
        #status,
        #gforce,
        #controls {
            position: fixed;
            color: #0f8;
            background: rgba(0, 0, 0, 0.88);
            padding: 12px 16px;
            border: 1px solid #0f8;
            border-radius: 6px;
            font-size: 11px;
            line-height: 1.5;
            z-index: 100;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Orbitron', sans-serif;
        }

        #hud {
            left: 20px;
            top: 20px;
        }

        #status {
            right: 20px;
            top: 20px;
        }

        #gforce {
            left: 20px;
            top: 200px;
            color: #ff0;
            border: 1px solid #ff0;
            font-size: 15px;
            font-weight: bold;
        }

        #controls {
            bottom: 30px;
            right: 20px;
            color: #0f0;
        }

        .label {
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            font-weight: 700;
        }

        #warp-countdown,
        #planet-arrival {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Orbitron', sans-serif;
            z-index: 200;
            text-align: center;
            pointer-events: none;
        }

        #warp-countdown {
            font-size: 60px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            display: none;
        }

        #planet-arrival {
            font-size: 48px;
            color: #0f8;
            text-shadow: 0 0 30px #0f8, 0 0 60px #0ff;
            opacity: 0;
            transition: opacity 1.5s ease-out;
            display: none;
        }

        #mission-hud {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #0ff;
            background: rgba(0, 0, 0, 0.88);
            padding: 8px 16px;
            border: 1px solid #0ff;
            border-radius: 6px;
            z-index: 100;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            text-transform: uppercase;
        }

        #station-name {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            color: #00ff00;
            text-shadow: 0 0 15px #00ff00;
            display: none;
            z-index: 200;
        }

        #docking-message {
            position: fixed;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #ffcc00;
            text-shadow: 0 0 10px #ffcc00;
            display: none;
            z-index: 200;
        }

        #minimapa {
            position: fixed;
            top: 20px;
            right: 200px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #0f8;
            border-radius: 50%;
            z-index: 100;
        }

        #synthwave-radio-player {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.88);
            border: 1px solid #0f8;
            border-radius: 6px;
            padding: 8px 16px;
            z-index: 150;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-size: 10px;
            box-shadow: 0 0 15px #0f8;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 280px;
        }

        .radio-title {
            color: #0ff;
            text-shadow: 0 0 8px #0ff;
            margin-bottom: 4px;
            animation: glow-pulse 3s infinite;
        }

        .radio-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #synthwave-radio-player button {
            background: none;
            border: 1px solid #0f8;
            color: #0f8;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
            text-shadow: 0 0 5px #0f8;
        }

        #synthwave-radio-player button:hover {
            background: #0f8;
            color: #000;
            box-shadow: 0 0 10px #0f8;
        }

        #pause-btn {
            display: none;
        }

        .volume-wrapper {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #0f8;
        }

        #volume-slider {
            width: 70px;
            accent-color: #0f8;
        }

        @keyframes glow-pulse {

            0%,
            100% {
                opacity: 0.8;
            }

            50% {
                opacity: 1;
                text-shadow: 0 0 12px #0ff;
            }
        }

        @media (max-width: 768px) {
            #synthwave-radio-player {
                top: 5px;
                min-width: 90%;
                left: 5%;
                transform: none;
                font-size: 9px;
            }
        }
    </style>
</head>

<body>
    <div id="hud">
        <div><span class="label">ALTITUDE</span>: <span id="alt">3000</span>m</div>
        <div><span class="label">VELOCIDADE</span>: <span id="vel">0</span> km/h</div>
        <div><span class="label">PITCH</span>: <span id="pitch">0</span>¬∞</div>
        <div><span class="label">ROLL</span>: <span id="roll">0</span>¬∞</div>
        <div><span class="label">AOA</span>: <span id="aoa">0</span>¬∞</div>
        <div><span class="label">BATTERY</span>: <span id="battery">0</span>%</div>
        <div><span class="label">MATERIAL</span>: <span id="material">0</span></div>
        <div><span class="label">MODULE</span>: <span id="module">NONE</span></div>
    </div>
    <div id="status">
        <div><span class="label">THROTTLE</span>: <span id="thr">50</span>%</div>
        <div><span class="label">FUEL</span>: <span id="fuel">100</span>%</div>
        <div><span class="label">HORA</span>: <span id="hora">12:00</span></div>
        <div><span class="label">STATUS</span>: <span id="stat">FLYING</span></div>
    </div>
    <div id="gforce">G-FORCE: <span id="g">1.0</span>G</div>
    <div id="controls">
        W/S=Throttle A/D=Yaw Q/E=Roll ‚Üë‚Üì=Pitch X=SUBIR C=TURBO Z=WARP 30x! SPACE=RESET T=DOCK<br>
        <span style="color:#0f0; font-size:14px;">WARP DRIVE 30x + SALTO INTERPLANET√ÅRIO</span>
    </div>
    <div id="warp-countdown"></div>
    <div id="planet-arrival"></div>
    <div id="mission-hud">MISS√ÉO: V√° para ENERGY STATION</div>
    <div id="station-name"></div>
    <div id="docking-message"></div>
    <div id="minimapa">
        <canvas id="minimap-canvas" width="150" height="150"
            style="width:100%;height:100%;display:block;border-radius:50%;background:rgba(0,0,0,0.25);"></canvas>
        <div id="minimap-info"
            style="position:absolute;bottom:6px;left:6px;color:#0f8;font-size:10px;font-family:'Orbitron',sans-serif;text-shadow:0 0 6px #0f8;pointer-events:none">
            --</div>
    </div>

    <div id="synthwave-radio-player">
        <div class="radio-title">NIGHTRIDE FM ¬∑ SYNTHWAVE 24/7</div>
        <div class="radio-controls">
            <button id="play-btn">‚ñ∂</button>
            <button id="pause-btn">‚è∏</button>
            <button id="stop-btn">‚èπ</button>
            <div class="volume-wrapper">
                <span>üîä</span>
                <input type="range" id="volume-slider" min="0" max="100" value="65">
            </div>
        </div>
    </div>

    <audio id="synthwave-stream" preload="none" crossorigin="anonymous">
        <source src="https://stream.nightride.fm/nightride.mp3" type="audio/mpeg">
    </audio>

    <script>
        const audio = document.getElementById('synthwave-stream');
        const playBtn = document.getElementById('play-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const volumeSlider = document.getElementById('volume-slider');
        playBtn.onclick = () => {
            audio.play().catch(e => console.log('Autoplay blocked:', e));
            playBtn.style.display = 'none';
            pauseBtn.style.display = 'inline-block';
        };
        pauseBtn.onclick = () => {
            audio.pause();
            playBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'none';
        };
        stopBtn.onclick = () => {
            audio.pause();
            audio.currentTime = 0;
            playBtn.style.display = 'inline-block';
            pauseBtn.style.display = 'none';
        };
        volumeSlider.oninput = (e) => {
            audio.volume = e.target.value / 100;
        };
        audio.volume = 0.65;

        function addMachinePart(station, index) {
            const part = new THREE.Mesh(new THREE.BoxGeometry(40, 40, 40), new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x0044aa }));
            part.position.set((index - 3) * 50, 50, 0);
            station.add(part);
        }

        function buildMachine(station) {
            const machineGroup = new THREE.Group();
            const core = new THREE.Mesh(new THREE.CylinderGeometry(20, 20, 200, 16), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 }));
            core.position.y = 100; machineGroup.add(core);
            const ringGeo = new THREE.TorusGeometry(60, 5, 16, 100);
            const ringMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff });
            const ring1 = new THREE.Mesh(ringGeo, ringMat);
            ring1.position.y = 100; ring1.rotation.x = Math.PI / 2; machineGroup.add(ring1);
            const ring2 = ring1.clone();
            ring2.rotation.x = Math.PI / 3; machineGroup.add(ring2);
            station.add(machineGroup);
        }
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const CONFIG = {
            PERFORMANCE_SAFE_MODE: false,
            SAFE_PLANET_SEGMENTS: 64,
            SAFE_PLANET_COUNT: 12,
            FIX_HUD_VELOCITY: false
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.000012);
        const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 3000000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sun = new THREE.DirectionalLight(0xffffe0, 2);
        scene.add(sun);

        const starGeo = new THREE.BufferGeometry();
        const starPositions = new Float32Array(12000 * 3);
        for (let i = 0; i < 12000; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 2000000 + Math.random() * 6000000;
            starPositions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            starPositions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            starPositions[i * 3 + 2] = r * Math.cos(phi);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 90, transparent: true, opacity: 0.9 }));
        scene.add(stars);
        stars.visible = false;

        function createPlanet(radius, segments = 180, isBrasil = false, planetType = 'diverse') {
            const geo = new THREE.SphereGeometry(radius, segments, segments);
            const pos = geo.attributes.position;
            const colors = new Float32Array(pos.count * 3);
            const group = new THREE.Group();

            let pyramidCount = 0;
            const PYRAMID_MAX = 3;
            const PYRAMID_HEIGHT = 1000;
            const PYRAMID_BASE = 1800;

            const noise = (a, b, freq = 1, amp = 1) => {
                return (Math.sin(a * freq * 0.08 + 10) * Math.cos(b * freq * 0.08 + 20)) * amp;
            };

            const fbm = (lat, lon) => {
                let val = 0;
                val += noise(lat, lon, 1, 1);
                val += noise(lat, lon, 2.7, 0.5);
                val += noise(lat, lon, 6.3, 0.25);
                val += noise(lat, lon, 15, 0.12);
                return val;
            };

            const getBiome = (lat, lon) => {
                if (planetType === 'ice') return { c: 0xADD8E6, n: "ice" };
                if (planetType === 'desert') return { c: 0xEDC9AF, n: "desert" };
                if (planetType === 'blue') {
                    if (Math.random() < 0.85) return { c: 0x00008B, n: "agua" };
                    else return { c: 0x228B22, n: "grama" };
                }
                if (isBrasil) lon -= 45;
                const n = fbm(lat * 2, lon * 2);
                if (lat > 8 && Math.abs(lon) < 55) return { c: 0x003300, n: "amazonia" };
                if (Math.abs(lat + 18) < 40 && Math.abs(lon) < 45) return { c: 0x8B6914, n: "cerrado" };
                if (lat > -25 && lat < -3 && lon > -30 && lon < -3) return { c: 0x2E8B57, n: "pantanal" };
                if (lon > 8) return { c: 0x006400, n: "mata_atlantica" };
                if (lat > -12 && lon > -18) return { c: 0xD2B48C, n: "caatinga" };
                if (lat < -32) return { c: 0x228B22, n: "pampas" };
                if (n > 0.9) return { c: 0x006994, n: "agua" };
                if (n > 0.3) return { c: 0x888888, n: "montanha" };
                return { c: 0x228B22, n: "grama" };
            };

            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i), y = pos.getY(i), z = pos.getZ(i);
                const len = Math.sqrt(x * x + y * y + z * z);
                if (len === 0) continue;
                const lat = Math.asin(Math.max(-1, Math.min(1, z / len))) * 180 / Math.PI;
                const lon = Math.atan2(y, x) * 180 / Math.PI;
                let height = fbm(lat, lon) * 1200;
                height += Math.max(0, fbm(lat * 0.4, lon * 0.4) - 0.2) * 6000;
                height += Math.max(0, fbm(lat * 8, lon * 8) - 0.6) * 800;
                if (getBiome(lat, lon).n === "montanha") height += 4000;
                const dir = new THREE.Vector3(x, y, z).normalize();
                if (!isFinite(dir.x) || !isFinite(dir.y) || !isFinite(dir.z)) continue;
                dir.multiplyScalar(radius + height);
                pos.setXYZ(i, dir.x, dir.y, dir.z);
                const b = getBiome(lat, lon);
                colors[i * 3] = (b.c >> 16 & 255) / 255;
                colors[i * 3 + 1] = (b.c >> 8 & 255) / 255;
                colors[i * 3 + 2] = (b.c & 255) / 255;

                if (b.n !== "agua" && b.n !== "ice" && b.n !== "desert" && radius > 60000 && i % Math.floor(400 - radius / 800) === 0 && Math.random() < 0.9) {
                    const worldPos = dir.clone().multiplyScalar(1);
                    const up = dir.clone().normalize();

                    if (!CONFIG.PERFORMANCE_SAFE_MODE) {
                        if ((b.n === "amazonia" || b.n === "mata_atlantica" || b.n === "grama") && (planetType === 'diverse' || planetType === 'blue')) {
                            const tree = new THREE.Group();
                            const trunkH = 120 + Math.random() * 80;
                            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(12, 20, trunkH), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                            trunk.position.copy(worldPos.clone().add(up.clone().multiplyScalar(trunkH / 2)));
                            trunk.lookAt(worldPos); tree.add(trunk);
                            const leaves = new THREE.Mesh(new THREE.SphereGeometry(80), new THREE.MeshStandardMaterial({ color: 0x004400 }));
                            leaves.scale.y = 0.5;
                            leaves.position.copy(worldPos.clone().add(up.clone().multiplyScalar(trunkH + 40)));
                            leaves.lookAt(worldPos); tree.add(leaves);
                            group.add(tree);
                        }

                        if (pyramidCount < PYRAMID_MAX) {
                            const pyrGeo = new THREE.BufferGeometry();
                            const half = PYRAMID_BASE / 2;
                            const pyrVertices = new Float32Array([
                                -half, 0, -half, half, 0, -half, half, 0, half, -half, 0, half,
                                0, PYRAMID_HEIGHT, 0
                            ]);
                            const pyrIndices = new Uint32Array([
                                0, 1, 2, 0, 2, 3,
                                0, 4, 1, 1, 4, 2, 2, 4, 3, 3, 4, 0
                            ]);
                            pyrGeo.setAttribute('position', new THREE.BufferAttribute(pyrVertices, 3));
                            pyrGeo.setIndex(new THREE.BufferAttribute(pyrIndices, 1));
                            pyrGeo.computeVertexNormals();
                            const pyr = new THREE.Mesh(pyrGeo, new THREE.MeshStandardMaterial({
                                color: 0xd4a76a, emissive: 0x8b7355, metalness: 0.05, roughness: 0.85
                            }));
                            pyr.position.copy(worldPos);
                            pyr.lookAt(worldPos);
                            group.add(pyr);
                            pyramidCount++;
                        }

                        if (Math.random() < 0.45 && pyramidCount >= PYRAMID_MAX) {
                            const house = new THREE.Group();
                            const wall = new THREE.Mesh(
                                new THREE.BoxGeometry(200, 150, 150),
                                new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.9, metalness: 0.0 })
                            );
                            wall.position.copy(worldPos.clone().add(up.clone().multiplyScalar(75)));
                            wall.lookAt(worldPos);
                            house.add(wall);

                            const roofGeo = new THREE.BufferGeometry();
                            const roofVerts = new Float32Array([
                                -100, 0, -75, 100, 0, -75, 100, 0, 75, -100, 0, 75, 0, 100, 0
                            ]);
                            const roofIndices = new Uint32Array([0, 1, 4, 1, 2, 4, 2, 3, 4, 3, 0, 4]);
                            roofGeo.setAttribute('position', new THREE.BufferAttribute(roofVerts, 3));
                            roofGeo.setIndex(new THREE.BufferAttribute(roofIndices, 1));
                            roofGeo.computeVertexNormals();
                            const roof = new THREE.Mesh(roofGeo, new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.95 }));
                            roof.position.copy(worldPos.clone().add(up.clone().multiplyScalar(155)));
                            roof.lookAt(worldPos);
                            house.add(roof);
                            group.add(house);
                        }
                    }
                }
            }
            pos.needsUpdate = true;
            geo.computeVertexNormals();
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geo.computeBoundingSphere();
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.95, metalness: 0.05 }));
            mesh.name = "PlanetSurface"; // Identificador para raycasting
            const name = isBrasil ? "TERRA (BRASIL)" : planetNames[Math.floor(Math.random() * planetNames.length)];
            mesh.userData = { name, radius, materialType: planetMaterials[Math.floor(Math.random() * planetMaterials.length)] };
            group.add(mesh);
            group.userData = mesh.userData;
            return { mesh: group, radius: mesh.userData.radius };
        }

        const planetNames = [
            "NEON-7", "KRYPTOS", "OBSIDIAN PRIME", "AURORA VOID", "SYNTHARA", "DARKMATTER-9",
            "VANTA BLACK", "CHROME NEXUS", "PHANTOM GRID", "VOIDWAVE", "LUX ETERNAL", "OMEGA DRIFT",
            "NIGHTFALL STATION", "CYBERION", "SPECTRA", "ECLIPSE CORE", "PULSE ZERO", "HYPERION"
        ];
        const planetMaterials = ["NEON-PLASMA", "TIT√ÇNIO-7", "CRISTAL-VOID", "DARK-ENERGY", "SYNTH-METAL", "QUANTUM-DUST"];

        const BRASIL_RADIUS = 120000;
        const brasil = createPlanet(BRASIL_RADIUS, 220, true, 'diverse');
        scene.add(brasil.mesh);
        let currentPlanetMesh = brasil.mesh;
        let currentPlanetCenter = new THREE.Vector3(0, 0, 0);
        let currentRadius = BRASIL_RADIUS;

        const otherPlanets = [];
        const planetTypes = ['ice', 'desert', 'blue', 'diverse'];
        const MAX_PLANETS = CONFIG.PERFORMANCE_SAFE_MODE ? CONFIG.SAFE_PLANET_COUNT : 40;

        for (let i = 0; i < MAX_PLANETS; i++) {
            const scale = 6 + Math.random() * 16;
            const radius = (800 + Math.random() * 400) * scale * 10;
            const typeIndex = Math.floor(Math.random() * planetTypes.length);
            const planetType = planetTypes[typeIndex];
            const segs = CONFIG.PERFORMANCE_SAFE_MODE ? CONFIG.SAFE_PLANET_SEGMENTS : Math.min(200, 60 + Math.floor(scale * 9));
            const planet = createPlanet(radius, segs, false, planetType);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const dist = 2000000 + Math.random() * 6000000;
            planet.mesh.position.set(dist * Math.sin(phi) * Math.cos(theta), dist * Math.sin(phi) * Math.sin(theta), dist * Math.cos(phi));
            scene.add(planet.mesh);
            otherPlanets.push(planet);
        }

        let blackHoleMesh;
        function createBlackHole() {
            const group = new THREE.Group();
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(4000, 64, 64), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            group.add(sphere);
            const diskGeo = new THREE.RingGeometry(6000, 12000, 64);
            const diskMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, side: THREE.DoubleSide, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending });
            const disk = new THREE.Mesh(diskGeo, diskMat);
            disk.rotation.x = Math.PI / 2;
            group.add(disk);
            const glow = new THREE.PointLight(0xffaa00, 5, 50000);
            group.add(glow);
            group.position.set(10000000, 0, 0);
            scene.add(group);
            blackHoleMesh = group;
        }

        function createStation(type, position, powered = false) {
            const group = new THREE.Group();
            let platW = 200, platH = 20, platD = 200;
            let platColor = 0x333333;

            switch (type) {
                case 'fuel': platW = 240; platD = 160; platColor = 0x5a4b00; break;
                case 'energy': platW = 220; platD = 220; platColor = 0x222233; break;
                case 'intelligence': platW = 180; platD = 260; platColor = 0x003355; break;
                case 'material': platW = 260; platD = 200; platColor = 0x6b4423; break;
                case 'manufacture': platW = 300; platD = 220; platColor = 0x333333; break;
                case 'landing': platW = 420; platH = 12; platD = 420; platColor = 0x111111; break;
            }

            const platform = new THREE.Mesh(new THREE.BoxGeometry(platW, platH, platD), new THREE.MeshStandardMaterial({ color: platColor }));
            platform.receiveShadow = true;
            group.add(platform);

            const signColor = powered ? 0x00ff00 : 0xff0000;
            const sign = new THREE.Mesh(new THREE.BoxGeometry(100, 50, 5), new THREE.MeshStandardMaterial({ color: signColor }));
            sign.position.y = platH / 2 + 30;
            sign.position.z = -platD / 2 + 30;
            group.add(sign);

            if (type === 'fuel') {
                const pump = new THREE.Mesh(new THREE.BoxGeometry(20, 50, 20), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                pump.position.set(platW / 2 - 40, 25, 0); group.add(pump);
                const tankGeo = new THREE.CylinderGeometry(30, 30, 80, 16);
                const tankMat = new THREE.MeshStandardMaterial({ color: 0x886600, metalness: 0.6, roughness: 0.4 });
                const tank1 = new THREE.Mesh(tankGeo, tankMat);
                tank1.position.set(-60, 40, -40); group.add(tank1);
                const tank2 = new THREE.Mesh(tankGeo, tankMat);
                tank2.position.set(-60, 40, 40); group.add(tank2);
                const pipe = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 100), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                pipe.rotation.x = Math.PI / 2; pipe.position.set(-60, 10, 0); group.add(pipe);
                const light = new THREE.PointLight(0xff0000, 1, 100);
                light.position.set(0, 60, 0); group.add(light);
            }
            if (type === 'energy') {
                const beacon = new THREE.PointLight(0x00ffcc, 1.6, 1000);
                beacon.position.set(0, 180, 0); group.add(beacon);
                const tower = new THREE.Mesh(new THREE.CylinderGeometry(6, 6, 160), new THREE.MeshStandardMaterial({ color: 0x005577 }));
                tower.position.set(0, 80, 0); group.add(tower);
                const reactorBase = new THREE.Mesh(new THREE.CylinderGeometry(40, 50, 10, 32), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                reactorBase.position.y = 15; group.add(reactorBase);
                const reactorGlow = new THREE.PointLight(0x00ff00, 2, 100);
                reactorGlow.position.y = 25; group.add(reactorGlow);
                for (let i = 0; i < 4; i++) {
                    const coil = new THREE.Mesh(new THREE.TorusGeometry(15, 2, 8, 16), new THREE.MeshStandardMaterial({ color: 0x00ffcc, emissive: 0x004433 }));
                    coil.rotation.x = Math.PI / 2; coil.position.y = 40 + i * 20; group.add(coil);
                }
            }
            if (type === 'intelligence') {
                const dish = new THREE.Mesh(new THREE.SphereGeometry(40, 16, 12, 0, Math.PI * 2, 0, Math.PI * 0.3), new THREE.MeshStandardMaterial({ color: 0x99ddff, side: THREE.DoubleSide }));
                dish.position.set(-platW / 2 + 60, 80, 0); dish.rotation.x = -Math.PI / 4; group.add(dish);
                const antenna = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 60), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                antenna.position.set(-platW / 2 + 60, 80, 0); antenna.rotation.x = -Math.PI / 4; group.add(antenna);
                const screen = new THREE.Mesh(new THREE.BoxGeometry(80, 40, 6), new THREE.MeshStandardMaterial({ color: 0x002244, emissive: 0x004477 }));
                screen.position.set(0, 80, -platD / 2 + 20); group.add(screen);
                const rackGeo = new THREE.BoxGeometry(20, 60, 20);
                const rackMat = new THREE.MeshStandardMaterial({ color: 0x111122 });
                const rack1 = new THREE.Mesh(rackGeo, rackMat); rack1.position.set(40, 40, 40); group.add(rack1);
                const rack2 = new THREE.Mesh(rackGeo, rackMat); rack2.position.set(70, 40, 40); group.add(rack2);
                const light = new THREE.PointLight(0x0000ff, 1, 100);
                light.position.set(0, 60, 0); group.add(light);
            }
            if (type === 'material') {
                for (let i = 0; i < 6; i++) {
                    const crate = new THREE.Mesh(new THREE.BoxGeometry(30, 30, 30), new THREE.MeshStandardMaterial({ color: 0x8b5a2b }));
                    crate.position.set(-platW / 2 + 60 + (i % 3 * 35), 15 + Math.floor(i / 3) * 30, platD / 4);
                    group.add(crate);
                }
                const silo = new THREE.Mesh(new THREE.CylinderGeometry(25, 25, 60, 16), new THREE.MeshStandardMaterial({ color: 0x555555 }));
                silo.position.set(60, 30, -40); group.add(silo);
                const light = new THREE.PointLight(0xffaa00, 1, 100);
                light.position.set(0, 60, 0); group.add(light);
            }
            if (type === 'manufacture') {
                const assembly = new THREE.Mesh(new THREE.BoxGeometry(120, 40, 40), new THREE.MeshStandardMaterial({ color: 0x444444 }));
                assembly.position.set(0, 30, 0); group.add(assembly);
                const armBase = new THREE.Mesh(new THREE.CylinderGeometry(5, 8, 20), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
                armBase.position.set(-40, 50, 0); group.add(armBase);
                const armSeg1 = new THREE.Mesh(new THREE.BoxGeometry(5, 40, 5), new THREE.MeshStandardMaterial({ color: 0xaaaaaa }));
                armSeg1.position.set(-40, 70, 10); armSeg1.rotation.x = Math.PI / 4; group.add(armSeg1);
                const belt = new THREE.Mesh(new THREE.BoxGeometry(200, 5, 30), new THREE.MeshStandardMaterial({ color: 0x222222 }));
                belt.position.set(0, 10, 40); group.add(belt);
                const light = new THREE.PointLight(0x00ffff, 1, 100);
                light.position.set(0, 60, 0); group.add(light);
            }
            if (type === 'landing') {
                const ring = new THREE.Mesh(new THREE.TorusGeometry(platW / 2 - 40, 8, 8, 64), new THREE.MeshStandardMaterial({ color: 0x00ff88, emissive: 0x004422 }));
                ring.rotation.x = Math.PI / 2; ring.position.y = platH / 2 + 6; group.add(ring);
                const towerBase = new THREE.Mesh(new THREE.BoxGeometry(30, 100, 30), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                towerBase.position.set(platW / 2 - 40, 50, -platD / 2 + 40); group.add(towerBase);
                const towerTop = new THREE.Mesh(new THREE.CylinderGeometry(20, 10, 20, 6), new THREE.MeshStandardMaterial({ color: 0x00aaff, transparent: true, opacity: 0.7 }));
                towerTop.position.set(platW / 2 - 40, 110, -platD / 2 + 40); group.add(towerTop);
                for (let i = -1; i <= 1; i += 2) {
                    for (let j = -1; j <= 1; j += 2) {
                        const light = new THREE.Mesh(new THREE.BoxGeometry(5, 2, 5), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
                        light.position.set(i * 100, platH / 2 + 1, j * 100); group.add(light);
                    }
                }
                const light = new THREE.PointLight(0xffffff, 1, 150);
                light.position.set(0, 80, 0); group.add(light);
            }

            group.position.copy(position);
            group.userData = { type, powered, name: type.toUpperCase() + ' STATION' };
            if (type === 'landing') {
                group.userData.level = 0;
            }
            return group;
        }

        let currentStations = [];
        function generateStations(planetCenter, radius) {
            currentStations = [];
            const stationTypes = ['fuel', 'energy', 'intelligence', 'material', 'manufacture', 'landing'];
            const n = stationTypes.length;
            const desiredSeparation = 20000;
            const circleRadius = desiredSeparation / (2 * Math.sin(Math.PI / n));
            const basePoint = planetCenter.clone().add(new THREE.Vector3(0, 1, 0).multiplyScalar(radius + 40));
            const normal = basePoint.clone().sub(planetCenter).normalize();
            let arbitrary = Math.abs(normal.y) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
            const tangent1 = new THREE.Vector3().crossVectors(arbitrary, normal).normalize();
            const tangent2 = new THREE.Vector3().crossVectors(normal, tangent1).normalize();

            stationTypes.forEach((type, index) => {
                const angle = (index / n) * Math.PI * 2;
                const planarPos = basePoint.clone()
                    .add(tangent1.clone().multiplyScalar(circleRadius * Math.cos(angle)))
                    .add(tangent2.clone().multiplyScalar(circleRadius * Math.sin(angle)));

                const dir = planarPos.clone().sub(planetCenter).normalize();
                const rayStart = planetCenter.clone().add(dir.clone().multiplyScalar(radius + 10000));
                const rayDir = dir.clone().negate();
                const raycaster = new THREE.Raycaster(rayStart, rayDir);
                let targetMesh = currentPlanetMesh;
                if (currentPlanetMesh.isGroup) {
                    targetMesh = currentPlanetMesh.children.find(c => c.name === "PlanetSurface");
                    if (!targetMesh) targetMesh = currentPlanetMesh.children[0];
                }
                const intersects = raycaster.intersectObject(targetMesh, false);
                let surfaceDistance = radius;
                if (intersects.length > 0) {
                    surfaceDistance = intersects[0].point.distanceTo(planetCenter);
                }
                const pos = planetCenter.clone().add(dir.multiplyScalar(surfaceDistance + 15));
                const powered = !(type === 'intelligence' || type === 'landing');
                const station = createStation(type, pos, powered);
                station.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                scene.add(station);
                currentStations.push(station);
            });
        }

        // Moved init call

        const aircraft = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({ color: 0x1c2526, metalness: 0.8, roughness: 0.3 });
        const wingShape = new THREE.Shape();
        wingShape.moveTo(0, 0); wingShape.lineTo(55, 0); wingShape.lineTo(30, 60);
        wingShape.lineTo(-30, 60); wingShape.lineTo(-55, 0);
        const wings = new THREE.Mesh(new THREE.ExtrudeGeometry(wingShape, { depth: 0.8, bevelEnabled: true }), mat);
        wings.rotation.x = -Math.PI / 2; wings.position.y = -1; aircraft.add(wings);
        const tail = new THREE.Mesh(new THREE.BoxGeometry(0.8, 12, 18), mat);
        tail.position.set(0, 1.5, -28);
        const tailL = tail.clone(); tailL.rotation.z = Math.PI / 5; tailL.position.x = -4;
        const tailR = tail.clone(); tailR.rotation.z = -Math.PI / 5; tailR.position.x = 4;
        aircraft.add(tailL, tailR);
        const cockpit = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 12), new THREE.MeshStandardMaterial({ color: 0x050505, metalness: 1 }));
        cockpit.scale.set(1.5, 0.8, 2.2); cockpit.position.set(0, 3, 10); aircraft.add(cockpit);
        const ab = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 18, 12, 1, true),
            new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0, blending: THREE.AdditiveBlending }));
        ab.position.set(0, -1.5, -25); aircraft.add(ab);
        const flameGeo = new THREE.BufferGeometry();
        const flamePos = new Float32Array(2400);
        for (let i = 0; i < 2400; i += 3) {
            flamePos[i] = (Math.random() - 0.5) * 6;
            flamePos[i + 1] = -1.5 + (Math.random() - 0.5) * 2;
            flamePos[i + 2] = -25 + (Math.random() - 0.5) * 10;
        }
        flameGeo.setAttribute('position', new THREE.BufferAttribute(flamePos, 3));
        const flame = new THREE.Points(flameGeo, new THREE.PointsMaterial({ color: 0xff9500, size: 5, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false }));
        aircraft.add(flame); flame.visible = false;
        const warpParticles = new THREE.Points(
            new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(800 * 3), 3)),
            new THREE.PointsMaterial({ color: 0x00aaff, size: 10, blending: THREE.AdditiveBlending, transparent: true })
        );
        const warpPos = warpParticles.geometry.attributes.position.array;
        for (let i = 0; i < 2400; i += 3) {
            warpPos[i] = (Math.random() - 0.5) * 200;
            warpPos[i + 1] = (Math.random() - 0.5) * 200;
            warpPos[i + 2] = -50 - Math.random() * 100;
        }
        scene.add(warpParticles);
        warpParticles.visible = false;
        const otherShips = [];
        for (let i = 0; i < 10; i++) {
            const ship = aircraft.clone();
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            const r = 500000 + Math.random() * 2000000;
            ship.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
            ship.scale.set(1.5, 1.5, 1.5);
            scene.add(ship);
            otherShips.push(ship);
        }
        scene.add(aircraft);

        const portals = [];
        for (let i = 0; i < 6; i++) {
            const angle = i / 6 * Math.PI * 2;
            const pos = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle)).multiplyScalar(BRASIL_RADIUS + 2000);
            const dest = new THREE.Vector3(Math.cos(angle + Math.PI), 0, Math.sin(angle + Math.PI)).multiplyScalar(BRASIL_RADIUS + 2000);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(600, 80, 20, 60), new THREE.MeshBasicMaterial({ color: 0x00ff44, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending }));
            ring.position.copy(pos); ring.lookAt(0, 0, 0); ring.rotateX(Math.PI / 2); scene.add(ring);
            portals.push({ pos, dest, mesh: ring, newTime: i / 6 });
        }

        const arrowGroup = new THREE.Group();
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
        const tipConeMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const lineGeom = new THREE.CylinderGeometry(0.5, 0.5, 0.5, 8);
        const lineSegment = new THREE.Mesh(lineGeom, lineMat);
        arrowGroup.add(lineSegment);
        const tipCone = new THREE.Mesh(new THREE.ConeGeometry(1, 3, 12), tipConeMat);
        tipCone.position.z = 0.75;
        arrowGroup.add(tipCone);
        scene.add(arrowGroup);
        arrowGroup.visible = false;
        let arrowEnabled = false;

        window.addEventListener('keydown', (e) => {
            if (!e.key) return;
            const k = e.key.toLowerCase();
            if (k === 'f' && !e.repeat) { arrowEnabled = !arrowEnabled; }
            if (k === 'm' && !e.repeat) {
                const mini = document.getElementById('minimapa');
                if (mini) { const isHidden = mini.style.display === 'none'; mini.style.display = isHidden ? '' : 'none'; }
            }
        });
        const state = {
            pos: new THREE.Vector3(0, BRASIL_RADIUS + 3000, 0),
            vel: new THREE.Vector3(180, 0, 0),
            rot: { pitch: 0, roll: 0, yaw: 0 },
            rotVel: { pitch: 0, roll: 0, yaw: 0 },
            throttle: 0.5,
            fuel: 1.0,
            battery: 0,
            material: 0,
            module: null,
            crashed: false,
            mass: 24000,
            wingArea: 105,
            thrustMax: 120000,
            warp: false,
            docking: false,
            dockedStation: null,
            dockingTimer: 0,
            procedureTime: 0,
            missionStep: 'energy',
            modulesDelivered: 0,
            blackHoleUnlocked: false,
            machineBuilt: false
        };

        aircraft.position.copy(state.pos);
        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        const clock = new THREE.Clock();
        let timeOfDay = 0;
        let warpCountdown = 0;
        let warpDuration = 0;
        let isCountingDown = false;
        let preWarpPos = new THREE.Vector3();
        let stationDisplayTimer = 0;
        let dockingApproachTimer = 0;

        const countdownDiv = document.getElementById('warp-countdown');
        const arrivalDiv = document.getElementById('planet-arrival');
        const missionHud = document.getElementById('mission-hud');
        const stationNameDiv = document.getElementById('station-name');
        const dockingMessageDiv = document.getElementById('docking-message');

        const miniCanvas = document.getElementById('minimap-canvas');
        const miniCtx = miniCanvas ? miniCanvas.getContext('2d') : null;
        const miniInfo = document.getElementById('minimap-info');

        function updateMinimap() {
            if (!miniCtx) return;
            const w = miniCanvas.width;
            const h = miniCanvas.height;
            miniCtx.clearRect(0, 0, w, h);
            miniCtx.save();
            miniCtx.translate(w / 2, h / 2);
            miniCtx.beginPath();
            miniCtx.arc(0, 0, Math.min(w, h) / 2 - 2, 0, Math.PI * 2);
            miniCtx.fillStyle = 'rgba(0,0,0,0.25)';
            miniCtx.fill();
            miniCtx.lineWidth = 2;
            miniCtx.strokeStyle = '#00ff88';
            miniCtx.stroke();

            const MAP_RADIUS = 60000;
            let nearest = null;
            let nearestDist = Infinity;

            currentStations.forEach(st => {
                const rel = st.position.clone().sub(state.pos);
                const sx = (rel.x / MAP_RADIUS) * (w / 2);
                const sy = -(rel.z / MAP_RADIUS) * (h / 2);
                if (sx * sx + sy * sy > (w / 2 - 6) * (h / 2 - 6)) return;

                let col = '#00ffff';
                if (st.userData.type === 'fuel') col = '#ffcc00';
                if (st.userData.type === 'energy') col = '#ffff00';
                if (st.userData.type === 'landing') col = '#00ff00';
                if (st.userData.type === 'manufacture') col = '#ff77ff';

                miniCtx.beginPath();
                miniCtx.fillStyle = col;
                miniCtx.arc(sx, sy, 4, 0, Math.PI * 2);
                miniCtx.fill();

                miniCtx.fillStyle = '#002';
                miniCtx.font = '8px Orbitron, monospace';
                miniCtx.fillText(st.userData.type[0].toUpperCase(), sx - 3, sy + 3);

                const d = rel.length();
                if (d < nearestDist) { nearestDist = d; nearest = st; }
            });

            otherShips.forEach(s => {
                const rel = s.position.clone().sub(state.pos);
                const sx = (rel.x / MAP_RADIUS) * (w / 2);
                const sy = -(rel.z / MAP_RADIUS) * (h / 2);
                if (sx * sx + sy * sy > (w / 2 - 6) * (h / 2 - 6)) return;
                miniCtx.beginPath(); miniCtx.fillStyle = '#ff4444'; miniCtx.arc(sx, sy, 3, 0, Math.PI * 2); miniCtx.fill();
            });

            const fwd = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
            const angle = Math.atan2(fwd.x, fwd.z);
            miniCtx.save();
            miniCtx.rotate(-angle);
            miniCtx.beginPath();
            miniCtx.fillStyle = '#00ff88';
            miniCtx.moveTo(0, -8);
            miniCtx.lineTo(6, 6);
            miniCtx.lineTo(-6, 6);
            miniCtx.closePath();
            miniCtx.fill();
            miniCtx.restore();
            miniCtx.restore();

            if (miniInfo) {
                if (nearest) {
                    const distKm = Math.round(nearestDist / 1000);
                    miniInfo.textContent = `${nearest.userData.name || nearest.userData.type} ¬∑ ${distKm} km`;
                } else {
                    miniInfo.textContent = `ALT: ${Math.round((state.pos.clone().sub(currentPlanetCenter).length() - currentRadius))}m`;
                }
            }
        }

        function showPlanetArrival(name) {
            arrivalDiv.textContent = `WARP COMPLETE ¬∑ ${name}`;
            arrivalDiv.style.display = 'block';
            arrivalDiv.style.opacity = '1';
            setTimeout(() => {
                arrivalDiv.style.opacity = '0';
                setTimeout(() => arrivalDiv.style.display = 'none', 1500);
            }, 5000);
            // Moved init call
            state.missionStep = 'energy';
            state.battery = 0;
            state.material = 0;
            state.module = null;
        }

        function getNextStation() {
            const typeMap = {
                'energy': 'energy',
                'intelligence': 'intelligence',
                'material': 'material',
                'manufacture': 'manufacture',
                'landing': 'landing'
            };
            return currentStations.find(s => s.userData.type === typeMap[state.missionStep]);
        }

        function updateMissionHud() {
            const stepMap = {
                'energy': 'V√° para ENERGY STATION',
                'intelligence': 'V√° para INTELLIGENCE STATION',
                'material': 'V√° para MATERIAL STATION',
                'manufacture': 'V√° para MANUFACTURE STATION',
                'landing': 'V√° para LANDING STATION'
            };
            missionHud.textContent = `MISS√ÉO: ${stepMap[state.missionStep]}`;
        }

        function performProcedure(station, dt) {
            state.dockingTimer += dt;
            dockingMessageDiv.style.display = 'block';
            dockingMessageDiv.textContent = `Processando... Tempo restante: ${Math.ceil(state.procedureTime - state.dockingTimer)}s`;

            if (state.dockingTimer >= state.procedureTime) {
                state.dockingTimer = 0;
                switch (station.userData.type) {
                    case 'fuel':
                        state.fuel = 1.0;
                        dockingMessageDiv.textContent = 'Combust√≠vel cheio. Pressione T para decolar.';
                        break;
                    case 'energy':
                        state.battery = 100;
                        dockingMessageDiv.textContent = 'Bateria carregada. Pressione T para decolar.';
                        if (state.missionStep === 'energy') {
                            state.missionStep = 'intelligence';
                        }
                        break;
                    case 'intelligence':
                        dockingMessageDiv.textContent = `Planeta produz: ${currentPlanetMesh.userData.materialType}. Pressione T para decolar.`;
                        state.missionStep = 'material';
                        break;
                    case 'material':
                        state.material = 100;
                        dockingMessageDiv.textContent = 'Material coletado. Pressione T para decolar.';
                        state.missionStep = 'manufacture';
                        break;
                    case 'manufacture':
                        state.module = 'EXPANSION MODULE';
                        state.material = 0;
                        dockingMessageDiv.textContent = 'M√≥dulo constru√≠do. Pressione T para decolar.';
                        state.missionStep = 'landing';
                        break;
                    case 'landing':
                        state.modulesDelivered++;
                        addMachinePart(station, state.modulesDelivered);
                        if (state.modulesDelivered >= 5) {
                            state.blackHoleUnlocked = true;
                            state.machineBuilt = true;
                            dockingMessageDiv.textContent = 'MÔøΩQUINA DE DOBRA INFINITA CONSTRUÔøΩDA! COORDENADAS DO BURACO NEGRO DESBLOQUEADAS.';
                            state.missionStep = 'blackhole';
                            buildMachine(station);
                        } else {
                            dockingMessageDiv.textContent = 'MÔøΩdulo entregue (' + state.modulesDelivered + '/5). Retorne ÔøΩ ENERGY STATION.';
                            state.missionStep = 'energy';
                        }
                        state.module = null;
                        break;
                }
                state.dockedStation = station;
                state.docking = 'waiting_undock';
            }
        }

        function checkDocking() {
            currentStations.forEach(station => {
                const dist = state.pos.distanceTo(station.position);
                if (dist <= 800 && !state.docking) {
                    stationNameDiv.textContent = station.userData.name;
                    stationNameDiv.style.display = 'block';
                    stationDisplayTimer = 5;

                    if (keys['t']) {
                        if (station.userData.type === 'intelligence' && !station.userData.powered) {
                            if (state.battery > 0) {
                                station.userData.powered = true;
                                station.children[1].material.color.set(0x00ff00);
                                state.battery = 0;
                                dockingMessageDiv.textContent = 'Energia entregue. Esta√ß√£o ativada.';
                            } else {
                                dockingMessageDiv.textContent = 'PRECISA DE BATERIA (ENERGY STATION)';
                                dockingMessageDiv.style.display = 'block';
                                setTimeout(() => dockingMessageDiv.style.display = 'none', 3000);
                                return;
                            }
                        }
                        state.docking = true;
                        dockingApproachTimer = 3;
                        state.dockedStation = station;
                        keys['t'] = false;
                    }
                }
            });

            if (stationDisplayTimer > 0) {
                stationDisplayTimer -= clock.getDelta();
                if (stationDisplayTimer <= 0) {
                    stationNameDiv.style.display = 'none';
                }
            }
        }

        function handleDocking(dt) {
            if (state.docking === true) {
                dockingApproachTimer -= dt;
                if (dockingApproachTimer > 0) {
                    const targetPos = state.dockedStation.position.clone().add(state.dockedStation.up.clone().multiplyScalar(20));
                    state.pos.lerp(targetPos, 0.05);
                    aircraft.quaternion.slerp(state.dockedStation.quaternion, 0.05);
                    state.vel.set(0, 0, 0);
                } else {
                    switch (state.dockedStation.userData.type) {
                        case 'fuel': state.procedureTime = 5; break;
                        case 'energy': state.procedureTime = 10; break;
                        case 'intelligence': state.procedureTime = 8; break;
                        case 'material': state.procedureTime = 30; break;
                        case 'manufacture': state.procedureTime = 60; break;
                        case 'landing':
                            state.modulesDelivered++;
                            addMachinePart(state.dockedStation, state.modulesDelivered);  // ‚úÖ
                            if (state.modulesDelivered >= 5) {
                                state.blackHoleUnlocked = true;
                                state.machineBuilt = true;
                                dockingMessageDiv.textContent = 'M√ÅQUINA CONSTRU√çDA!';
                                state.missionStep = 'blackhole';
                                buildMachine(state.dockedStation);  // ‚úÖ
                            } else {
                                dockingMessageDiv.textContent = 'M√≥dulo entregue (' + state.modulesDelivered + '/5).';
                                state.missionStep = 'energy';
                            }
                            state.module = null;
                            break;
                    }
                    state.docking = 'processing';
                }
            } else if (state.docking === 'processing') {
                performProcedure(state.dockedStation, dt);
            } else if (state.docking === 'waiting_undock') {
                if (keys['t']) {
                    state.docking = false;
                    state.dockedStation = null;
                    dockingMessageDiv.style.display = 'none';
                    state.vel.add(new THREE.Vector3(0, 100, 0));
                    keys['t'] = false;
                }
            }
        }

        function updateArrow() {
            const nextStation = getNextStation();
            if (arrowEnabled && nextStation && !state.docking) {
                arrowGroup.visible = true;
                const targetDir = nextStation.position.clone().sub(state.pos).normalize();
                const noseOffset = 30;
                const nosePos = state.pos.clone().add(
                    new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion).multiplyScalar(noseOffset)
                );
                const fullDistance = nextStation.position.clone().sub(nosePos).length();
                const arrowLength = Math.min(fullDistance, 200);
                const midpoint = nosePos.clone().add(targetDir.clone().multiplyScalar(arrowLength / 2));
                arrowGroup.position.copy(midpoint);
                arrowGroup.lookAt(nosePos.clone().add(targetDir.multiplyScalar(arrowLength)));
                const lineSegment = arrowGroup.children[0];
                lineSegment.scale.z = arrowLength;
                const tipCone = arrowGroup.children[1];
                tipCone.position.z = arrowLength / 2;
            } else {
                arrowGroup.visible = false;
            }
        }

        function animate() {
            const dt = Math.min(clock.getDelta(), 0.033);
            timeOfDay = (timeOfDay + dt / 480) % 1;
            const angle = timeOfDay * Math.PI * 2;
            const sunY = Math.sin(angle) * 300000;
            sun.position.set(Math.cos(angle) * 300000, sunY, Math.sin(angle) * 300000);
            const intensity = Math.max(0, sunY / 300000);
            sun.intensity = intensity * 3;
            ambientLight.intensity = 0.3 + intensity * 0.7;
            scene.background = new THREE.Color().setHSL(0.58, 0.6, intensity * 0.5 + 0.1);
            stars.visible = intensity < 0.3;
            scene.fog.density = intensity < 0.3 ? 0.000010 : 0.000025;

            const h = Math.floor(timeOfDay * 24) % 24;
            const m = Math.floor(timeOfDay * 1440) % 60;
            document.getElementById('hora').textContent = `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}`;

            let forward = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
            let up = new THREE.Vector3(0, 1, 0).applyQuaternion(aircraft.quaternion);
            let accel = new THREE.Vector3(0, 0, 0);

            if (state.docking) {
                state.vel.set(0, 0, 0);
                handleDocking(dt);
            } else {
                if (keys['c']) state.vel.add(new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion).multiplyScalar(1800 * dt));
                if (keys['x']) state.vel.add(new THREE.Vector3(0, 1, 0).applyQuaternion(aircraft.quaternion).multiplyScalar(3000 * dt));
                if (keys[' ']) {
                    state.pos = currentPlanetCenter.clone().add(new THREE.Vector3(0, currentRadius + 3000, 0));
                    state.vel.set(180, 0, 0);
                    state.rot = { pitch: 0, roll: 0, yaw: 0 };
                    state.rotVel = { pitch: 0, roll: 0, yaw: 0 };
                    state.throttle = 0.5;
                    state.fuel = 1.0;
                    state.crashed = false;
                }

                const inputThr = (keys['w'] ? 1 : 0) - (keys['s'] ? 1 : 0);
                const inputYaw = (keys['a'] ? 1 : 0) - (keys['d'] ? 1 : 0);
                const inputRoll = (keys['e'] ? 1 : 0) - (keys['q'] ? 1 : 0);
                const inputPitch = (keys['arrowup'] ? 1 : 0) - (keys['arrowdown'] ? 1 : 0);

                state.throttle = THREE.MathUtils.clamp(state.throttle + inputThr * dt * 0.8, 0, 1);
                state.fuel = Math.max(0, state.fuel - state.throttle * dt * 0.00008);

                state.rotVel.pitch += inputPitch * 3 * dt;
                state.rotVel.roll += inputRoll * 3.5 * dt;
                state.rotVel.yaw += inputYaw * 2 * dt;

                state.rotVel.pitch *= 0.98; state.rotVel.roll *= 0.98; state.rotVel.yaw *= 0.94;

                state.rot.pitch += state.rotVel.pitch * dt;
                state.rot.roll += state.rotVel.roll * dt;
                state.rot.yaw += state.rotVel.yaw * dt;

                state.rot.pitch = THREE.MathUtils.clamp(state.rot.pitch, -1.4, 1.2);

                const euler = new THREE.Euler(state.rot.pitch, state.rot.yaw, state.rot.roll, 'YXZ');
                aircraft.quaternion.setFromEuler(euler);
                aircraft.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI));

                forward = new THREE.Vector3(0, 0, -1).applyQuaternion(aircraft.quaternion);
                up = new THREE.Vector3(0, 1, 0).applyQuaternion(aircraft.quaternion);

                accel = new THREE.Vector3(0, 0, 0);

                if (keys['z'] && !isCountingDown && !state.warp) {
                    isCountingDown = true;
                    warpCountdown = 3;
                    countdownDiv.style.display = 'block';
                    countdownDiv.textContent = 'WARP: 3';
                    preWarpPos.copy(state.pos);
                }

                if (isCountingDown) {
                    warpCountdown -= dt;
                    countdownDiv.textContent = `WARP: ${Math.ceil(warpCountdown)}`;
                    if (warpCountdown <= 0) {
                        isCountingDown = false;
                        countdownDiv.style.display = 'none';
                        state.warp = true;
                        warpDuration = 2;
                    }
                }

                if (state.warp) {
                    warpDuration -= dt;
                    const warpImpulse = forward.clone().multiplyScalar(12000000 * dt);
                    state.vel.add(warpImpulse);
                    state.vel.setLength(Math.min(state.vel.length(), 80000));
                    state.fuel -= dt * 0.0003;
                    warpParticles.visible = true;
                    warpParticles.position.copy(state.pos);
                    warpParticles.quaternion.copy(aircraft.quaternion);
                    const wp = warpParticles.geometry.attributes.position.array;
                    for (let i = 0; i < wp.length; i += 3) {
                        wp[i + 2] -= 15000 * dt;
                        if (wp[i + 2] < -300) {
                            wp[i] = (Math.random() - 0.5) * 500;
                            wp[i + 1] = (Math.random() - 0.5) * 500;
                            wp[i + 2] = -50;
                        }
                    }
                    warpParticles.geometry.attributes.position.needsUpdate = true;

                    const _rawVel = state.vel.length();
                    let _velDisplay;
                    if (CONFIG.FIX_HUD_VELOCITY) {
                        _velDisplay = (_rawVel * 3.6).toFixed(1) + " km/h";
                    } else {
                        _velDisplay = (_rawVel * 3.6 * 100).toFixed(1) + "c";
                    }
                    document.getElementById('vel').textContent = _velDisplay;
                    document.getElementById('g').textContent = "‚àû";
                    document.getElementById('alt').textContent = "ESPA√áO LIVRE";

                    if (warpDuration <= 0) {
                        state.warp = false;
                        warpParticles.visible = false;
                        state.vel.copy(forward.clone().multiplyScalar(180));
                        if (state.blackHoleUnlocked) {
                            state.pos.copy(blackHoleMesh.position.clone().add(new THREE.Vector3(0, 0, 100000)));
                            state.vel.set(0, 0, -500);
                            showPlanetArrival('BLACK HOLE HORIZON');
                        } else {
                            let candidates = otherPlanets.filter(p => p.mesh !== currentPlanetMesh);
                            if (candidates.length === 0) candidates = otherPlanets;
                            const chosen = candidates[Math.floor(Math.random() * candidates.length)];
                            currentPlanetMesh = chosen.mesh;
                            currentPlanetCenter.copy(chosen.mesh.position);
                            currentRadius = chosen.radius;
                            const direction = preWarpPos.clone().sub(currentPlanetCenter).normalize();
                            state.pos.copy(currentPlanetCenter.clone().add(direction.multiplyScalar(currentRadius + 5000)));
                            showPlanetArrival(currentPlanetMesh.userData.name);
                            // Regenerate stations for new planet
                            currentStations.forEach(s => scene.remove(s));
                            generateStations(currentPlanetCenter, currentRadius);
                        }
                    }
                } else if (!isCountingDown) {
                    // Physics Safeguards
                    if (isNaN(state.pos.x) || isNaN(state.vel.x)) {
                        console.warn("Physics NaN detected! Resetting position.");
                        state.pos.copy(currentPlanetCenter.clone().add(new THREE.Vector3(0, currentRadius + 5000, 0)));
                        state.vel.set(0, 0, 0);
                    }

                    const speed = state.vel.length();
                    accel = forward.clone().multiplyScalar(state.thrustMax * state.throttle * state.fuel / state.mass);
                    const drag = 0.5 * 1.225 * speed * speed * 0.04 * state.wingArea;
                    accel.add(state.vel.clone().normalize().multiplyScalar(-drag / state.mass));
                    const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));
                    const lift = 0.5 * 1.225 * speed * speed * 2 * state.wingArea * Math.sin(aoa);
                    accel.add(up.clone().multiplyScalar(lift / state.mass));

                    const toCenter = state.pos.clone().sub(currentPlanetCenter);
                    const dist = Math.max(100, toCenter.length()); // Clamp distance
                    accel.add(toCenter.normalize().multiplyScalar(-9.81 * (currentRadius / dist) ** 2));

                    state.vel.add(accel.multiplyScalar(dt));

                    // Clamp velocity
                    if (state.vel.length() > 50000) {
                        state.vel.setLength(50000);
                    }
                }

                state.pos.add(state.vel.clone().multiplyScalar(dt));

                if (!state.warp) {
                    const toCenter = state.pos.clone().sub(currentPlanetCenter);
                    const distanceFromCenter = toCenter.length();
                    const rayDirection = toCenter.clone().normalize();
                    const raycaster = new THREE.Raycaster(currentPlanetCenter, rayDirection, 0, distanceFromCenter + 10000);
                    const intersects = raycaster.intersectObject(currentPlanetMesh, true);

                    let realSurfaceDistance = currentRadius;
                    if (intersects.length > 0 && intersects[0].distance > 1000) {
                        realSurfaceDistance = intersects[0].distance;
                    }

                    const altitude = distanceFromCenter - realSurfaceDistance;
                    document.getElementById('alt').textContent = Math.max(0, Math.round(altitude));

                    if (altitude < 8) {
                        const safeDistance = realSurfaceDistance + 8;
                        state.pos.copy(currentPlanetCenter.clone().add(rayDirection.multiplyScalar(safeDistance)));
                        const radialVel = rayDirection.dot(state.vel);
                        if (radialVel < 0) {
                            state.vel.sub(rayDirection.multiplyScalar(radialVel * 1.1));
                        }
                        if (state.vel.length() > 280 || Math.abs(radialVel) > 180) {
                            state.crashed = true;
                            state.vel.multiplyScalar(0.15);
                        }
                    }
                }

                otherPlanets.forEach(p => {
                    if (p.mesh === currentPlanetMesh) return;
                    const vecToPlanet = state.pos.clone().sub(p.mesh.position);
                    const distToPlanet = vecToPlanet.length();
                    if (distToPlanet < p.radius + 50) {
                        const normal = vecToPlanet.normalize();
                        state.pos.copy(p.mesh.position.clone().add(normal.multiplyScalar(p.radius + 50)));
                        const velIntoPlanet = normal.dot(state.vel);
                        if (velIntoPlanet < 0) state.vel.sub(normal.multiplyScalar(velIntoPlanet));
                        if (state.vel.length() > 150) state.crashed = true;
                    }
                });
            }

            aircraft.position.copy(state.pos);
            const camOffset = new THREE.Vector3(0, 90, 300).applyQuaternion(aircraft.quaternion);
            camera.position.lerp(state.pos.clone().add(camOffset), 0.1);
            camera.lookAt(state.pos.clone().add(forward.clone().multiplyScalar(300)));

            ab.material.opacity = state.throttle > 0.6 ? (state.throttle - 0.6) * 2.5 : 0;
            flame.visible = state.throttle > 0.72 || keys['c'];
            if (flame.visible) {
                const p = flame.geometry.attributes.position.array;
                for (let i = 0; i < p.length; i += 3) {
                    p[i + 2] -= 3000 * dt;
                    if (p[i + 2] < -100) p[i + 2] = -20;
                }
                flame.geometry.attributes.position.needsUpdate = true;
            }

            portals.forEach(p => {
                p.mesh.rotation.z += dt * 1.5;
                if (state.pos.distanceTo(p.pos) < 800) {
                    state.pos.copy(p.dest);
                    timeOfDay = p.newTime;
                }
            });

            if (!state.warp) {
                const toCenter = state.pos.clone().sub(currentPlanetCenter);
                const dist = toCenter.length();
                const altitude = dist - currentRadius;
                const speed = state.vel.length();
                const aoa = Math.atan2(-state.vel.dot(up), state.vel.dot(forward));
                document.getElementById('vel').textContent = Math.round(speed * 3.6);
                document.getElementById('aoa').textContent = THREE.MathUtils.radToDeg(aoa).toFixed(1);
                document.getElementById('g').textContent = (accel.length() / 9.81 + 1).toFixed(1);
            }

            document.getElementById('thr').textContent = Math.round(state.throttle * 100);
            document.getElementById('pitch').textContent = THREE.MathUtils.radToDeg(state.rot.pitch).toFixed(1);
            document.getElementById('roll').textContent = THREE.MathUtils.radToDeg(state.rot.roll).toFixed(1);
            document.getElementById('fuel').textContent = Math.round(state.fuel * 100);
            document.getElementById('battery').textContent = state.battery;
            document.getElementById('material').textContent = state.material;
            document.getElementById('module').textContent = state.module || 'NONE';
            document.getElementById('stat').textContent = state.crashed ? 'CRASHED' : 'FLYING';

            updateMissionHud();
            updateArrow();
            updateMinimap();
            checkDocking();

            if (state.blackHoleUnlocked && blackHoleMesh) {
                const dist = state.pos.distanceTo(blackHoleMesh.position);
                if (dist < 50000) {
                    document.getElementById('planet-arrival').textContent = 'INFINITE WARP ACHIEVED - MISSION COMPLETE';
                    document.getElementById('planet-arrival').style.display = 'block';
                    document.getElementById('planet-arrival').style.opacity = 1;
                    camera.fov = 70 + Math.sin(Date.now() * 0.01) * 10;
                    camera.updateProjectionMatrix();
                }
            }
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });

        generateStations(currentPlanetCenter, currentRadius);
        createBlackHole();

        animate();

        function addMachinePart(station, index) {
            const part = new THREE.Mesh(new THREE.BoxGeometry(40, 40, 40), new THREE.MeshStandardMaterial({ color: 0x00aaff, emissive: 0x0044aa }));
            part.position.set((index - 3) * 50, 50, 0);
            station.add(part);
        }

        function buildMachine(station) {
            const machineGroup = new THREE.Group();
            const core = new THREE.Mesh(new THREE.CylinderGeometry(20, 20, 200, 16), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 }));
            core.position.y = 100; machineGroup.add(core);
            const ringGeo = new THREE.TorusGeometry(60, 5, 16, 100);
            const ringMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0xff00ff });
            const ring1 = new THREE.Mesh(ringGeo, ringMat);
            ring1.position.y = 100; ring1.rotation.x = Math.PI / 2; machineGroup.add(ring1);
            const ring2 = ring1.clone();
            ring2.rotation.x = Math.PI / 3; machineGroup.add(ring2);
            station.add(machineGroup);
        }
    </script>
</body>

</html>
